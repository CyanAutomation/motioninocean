============================= test session starts ==============================
platform linux -- Python 3.12.3, pytest-8.4.2, pluggy-1.6.0 -- /workspaces/MotionInOcean/.venv/bin/python
cachedir: .pytest_cache
rootdir: /workspaces/MotionInOcean
configfile: pyproject.toml
plugins: cov-7.0.0, anyio-4.12.1
collecting ... collected 295 items

tests/test_application_settings.py::TestApplicationSettingsBasic::test_init_creates_path PASSED [  0%]
tests/test_application_settings.py::TestApplicationSettingsBasic::test_load_default_schema PASSED [  0%]
tests/test_application_settings.py::TestApplicationSettingsBasic::test_save_and_load PASSED [  1%]
tests/test_application_settings.py::TestApplicationSettingsGetSet::test_get_single_value PASSED [  1%]
tests/test_application_settings.py::TestApplicationSettingsGetSet::test_get_default_when_not_set PASSED [  1%]
tests/test_application_settings.py::TestApplicationSettingsGetSet::test_set_multiple_in_category PASSED [  2%]
tests/test_application_settings.py::TestApplicationSettingsGetSet::test_set_invalid_category_raises PASSED [  2%]
tests/test_application_settings.py::TestApplicationSettingsGetSet::test_set_invalid_property_raises PASSED [  2%]
tests/test_application_settings.py::TestApplicationSettingsFeatureFlags::test_set_feature_flag PASSED [  3%]
tests/test_application_settings.py::TestApplicationSettingsFeatureFlags::test_update_feature_flags PASSED [  3%]
tests/test_application_settings.py::TestApplicationSettingsReset::test_reset_clears_file PASSED [  3%]
tests/test_application_settings.py::TestApplicationSettingsReset::test_load_after_reset_returns_defaults PASSED [  4%]
tests/test_application_settings.py::TestApplicationSettingsReset::test_load_coerces_invalid_feature_flags_to_empty_dict PASSED [  4%]
tests/test_application_settings.py::TestApplicationSettingsChanges::test_get_changes_shows_overrides PASSED [  4%]
tests/test_application_settings.py::TestApplicationSettingsChanges::test_get_changes_handles_invalid_feature_flag_maps PASSED [  5%]
tests/test_application_settings.py::TestApplicationSettingsValidation::test_invalid_root_type_raises PASSED [  5%]
tests/test_application_settings.py::TestApplicationSettingsValidation::test_missing_required_categories_raises PASSED [  5%]
tests/test_application_settings.py::TestApplicationSettingsValidation::test_invalid_version_raises PASSED [  6%]
tests/test_application_settings.py::TestApplicationSettingsConcurrency::test_concurrent_save_safe PASSED [  6%]
tests/test_application_settings.py::TestApplicationSettingsConcurrency::test_concurrent_set_keeps_updates_to_different_keys PASSED [  6%]
tests/test_application_settings.py::TestApplicationSettingsConcurrency::test_concurrent_update_category_keeps_updates_to_different_keys PASSED [  7%]
tests/test_application_settings.py::TestApplicationSettingsConcurrency::test_load_acquires_lock PASSED [  7%]
tests/test_application_settings.py::TestApplicationSettingsConcurrency::test_load_handles_file_removed_after_exists_check PASSED [  7%]
tests/test_application_settings.py::TestApplicationSettingsFileCorruption::test_corrupted_json_raises PASSED [  8%]
tests/test_application_settings.py::TestApplicationSettingsFileCorruption::test_corrupted_file_recovery PASSED [  8%]
tests/test_cat_gif_generator.py::TestFetchCatGif::test_fetch_cat_gif_success PASSED [  8%]
tests/test_cat_gif_generator.py::TestFetchCatGif::test_fetch_cat_gif_timeout PASSED [  9%]
tests/test_cat_gif_generator.py::TestFetchCatGif::test_fetch_cat_gif_http_error PASSED [  9%]
tests/test_cat_gif_generator.py::TestFetchCatGif::test_fetch_cat_gif_url_error PASSED [  9%]
tests/test_cat_gif_generator.py::TestExtractGifFrames::test_extract_single_frame_gif PASSED [ 10%]
tests/test_cat_gif_generator.py::TestExtractGifFrames::test_extract_animated_gif PASSED [ 10%]
tests/test_cat_gif_generator.py::TestExtractGifFrames::test_extract_gif_frames_respects_resolution PASSED [ 10%]
tests/test_cat_gif_generator.py::TestExtractGifFrames::test_extract_gif_frames_respects_quality PASSED [ 11%]
tests/test_cat_gif_generator.py::TestExtractGifFrames::test_extract_gif_frames_invalid_data PASSED [ 11%]
tests/test_cat_gif_generator.py::TestExtractGifFrames::test_extract_gif_frames_empty_input PASSED [ 11%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_initialization PASSED [ 12%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_target_fps_minimum PASSED [ 12%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_request_refresh PASSED [ 12%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_cache_expiration PASSED [ 13%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_generate_frames_with_fallback PASSED [ 13%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_generate_frames_with_valid_gif PASSED [ 13%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_generate_frames_refresh_request_honored PASSED [ 14%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_generate_frames_fetch_happens_outside_lock_for_refresh PASSED [ 14%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_generate_frames_fetch_happens_outside_lock_for_cache_expiry PASSED [ 14%]
tests/test_cat_gif_generator.py::TestCatGifGenerator::test_generate_frames_handles_frame_list_shrinking PASSED [ 15%]
tests/test_cat_gif_generator.py::TestCatGifGeneratorIntegration::test_full_workflow_with_mock_api PASSED [ 15%]
tests/test_concurrency.py::TestThreadSafety::test_stream_stats_concurrent_writes PASSED [ 15%]
tests/test_concurrency.py::TestThreadSafety::test_stream_stats_concurrent_reads PASSED [ 16%]
tests/test_concurrency.py::TestThreadSafety::test_frame_buffer_concurrent_write_read PASSED [ 16%]
tests/test_concurrency.py::TestConcurrentStreamAccess::test_multiple_stream_connections PASSED [ 16%]
tests/test_concurrency.py::TestConcurrentStreamAccess::test_connection_tracking_race_condition PASSED [ 17%]
tests/test_concurrency.py::TestSignalHandling::test_shutdown_event_flag PASSED [ 17%]
tests/test_concurrency.py::TestSignalHandling::test_mock_thread_cleanup_timeout PASSED [ 17%]
tests/test_concurrency.py::TestSignalHandling::test_mock_thread_forced_termination PASSED [ 18%]
tests/test_concurrency.py::TestResourceExhaustion::test_frame_size_limit_enforcement PASSED [ 18%]
tests/test_concurrency.py::TestResourceExhaustion::test_frame_buffer_memory_protection PASSED [ 18%]
tests/test_concurrency.py::TestResourceExhaustion::test_stream_timeout_handling PASSED [ 19%]
tests/test_concurrency.py::TestResourceExhaustion::test_concurrent_frame_writes_under_load PASSED [ 19%]
tests/test_concurrency.py::TestMonotonicTiming::test_uptime_calculation_monotonic PASSED [ 20%]
tests/test_concurrency.py::TestMonotonicTiming::test_frame_age_calculation PASSED [ 20%]
tests/test_concurrency.py::TestMonotonicTiming::test_timing_immune_to_clock_changes PASSED [ 20%]
tests/test_config.py::test_python_syntax PASSED                          [ 21%]
tests/test_config.py::test_docker_compose_valid_yaml PASSED              [ 21%]
tests/test_config.py::test_docker_compose_has_service PASSED             [ 21%]
tests/test_config.py::test_docker_compose_required_fields PASSED         [ 22%]
tests/test_config.py::test_docker_compose_environment_config PASSED      [ 22%]
tests/test_config.py::test_docker_compose_healthcheck PASSED             [ 22%]
tests/test_config.py::test_docker_compose_device_mappings PASSED         [ 23%]
tests/test_config.py::test_docker_compose_security PASSED                [ 23%]
tests/test_config.py::test_flask_endpoint_defined[/-@app.route("/")] PASSED [ 23%]
tests/test_config.py::test_flask_endpoint_defined[/health-@app.route("/health")] PASSED [ 24%]
tests/test_config.py::test_flask_endpoint_defined[/ready-@app.route("/ready")] PASSED [ 24%]
tests/test_config.py::test_flask_endpoint_defined[/stream.mjpg-@app.route("/stream.mjpg")] PASSED [ 24%]
tests/test_config.py::test_flask_endpoint_defined[/webcam-@app.route("/webcam")] PASSED [ 25%]
tests/test_config.py::test_flask_endpoint_defined[/webcam/-@app.route("/webcam/")] PASSED [ 25%]
tests/test_config.py::test_error_handling_present[PermissionError-except PermissionError] PASSED [ 25%]
tests/test_config.py::test_error_handling_present[RuntimeError-except RuntimeError] PASSED [ 26%]
tests/test_config.py::test_error_handling_present[General exception-except Exception] PASSED [ 26%]
tests/test_config.py::test_error_handling_present[Try-finally-finally:] PASSED [ 26%]
tests/test_config.py::test_environment_variable_handled[RESOLUTION] PASSED [ 27%]
tests/test_config.py::test_environment_variable_handled[FPS] PASSED      [ 27%]
tests/test_config.py::test_env_file_exists PASSED                        [ 27%]
tests/test_config.py::test_env_file_has_required_variables[TZ] PASSED    [ 28%]
tests/test_config.py::test_env_file_has_required_variables[RESOLUTION] PASSED [ 28%]
tests/test_config.py::test_dockerfile_has_required_elements[Base image-pattern0] PASSED [ 28%]
tests/test_config.py::test_dockerfile_has_required_elements[Python picamera2-picamera2] SKIPPED [ 29%]
tests/test_config.py::test_dockerfile_has_required_elements[Python flask-python3-flask] PASSED [ 29%]
tests/test_config.py::test_dockerfile_has_required_elements[Working directory-WORKDIR /app] PASSED [ 29%]
tests/test_config.py::test_dockerfile_has_required_elements[Entry point-CMD] PASSED [ 30%]
tests/test_config.py::test_pi3_profile_applies_defaults_when_explicit_env_absent PASSED [ 30%]
tests/test_config.py::test_manual_env_values_override_pi3_profile_defaults PASSED [ 30%]
tests/test_config.py::test_legacy_pi3_profile_env_var_is_still_supported PASSED [ 31%]
tests/test_config.py::test_metrics_remain_stable_under_pi3_target_fps_throttle PASSED [ 31%]
tests/test_config.py::test_octoprint_compat_webcam_routes_support_trailing_and_non_trailing_slash PASSED [ 31%]
tests/test_config.py::test_octoprint_compat_webcam_action_normalization PASSED [ 32%]
tests/test_config.py::test_detect_devices_script_includes_v4l_subdev PASSED [ 32%]
tests/test_config.py::test_setup_ui_detect_camera_devices_collects_v4l_subdev SKIPPED [ 32%]
tests/test_config.py::test_setup_ui_generated_compose_includes_v4l_subdev_mapping PASSED [ 33%]
tests/test_discovery.py::test_load_config_discovery_defaults PASSED      [ 33%]
tests/test_discovery.py::test_load_config_discovery_overrides PASSED     [ 33%]
tests/test_discovery.py::test_build_discovery_payload_uses_override_node_id PASSED [ 34%]
tests/test_discovery.py::test_discovery_announcer_stop_sets_shutdown_event PASSED [ 34%]
tests/test_discovery.py::test_build_discovery_payload_requires_base_url PASSED [ 34%]
tests/test_discovery.py::test_discovery_announcer_log_url_redacts_query_and_credentials PASSED [ 35%]
tests/test_discovery_integration.py::TestDiscoveryAnnounceIntegration::test_announcer_makes_successful_announcement PASSED [ 35%]
tests/test_discovery_integration.py::TestDiscoveryAnnounceIntegration::test_announcer_handles_http_error PASSED [ 35%]
tests/test_discovery_integration.py::TestDiscoveryAnnounceIntegration::test_announcer_handles_network_timeout PASSED [ 36%]
tests/test_discovery_integration.py::TestDiscoveryAnnounceIntegration::test_announcer_retries_with_exponential_backoff PASSED [ 36%]
tests/test_discovery_integration.py::TestDiscoveryAnnounceIntegration::test_announcer_thread_lifecycle PASSED [ 36%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_webcam_announces_to_management_and_gets_approved PASSED [ 37%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_webcam_announces_with_private_ip_blocked_without_opt_in PASSED [ 37%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_webcam_announces_with_private_ip_allowed_with_opt_in PASSED [ 37%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_webcam_discovery_payload_structure PASSED [ 38%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_multiple_webcams_announce_independently PASSED [ 38%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_discovery_announce_without_shared_secret_fails PASSED [ 38%]
tests/test_discovery_integration.py::TestDiscoveryEndToEnd::test_discovery_node_updates_last_announce_timestamp PASSED [ 39%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_feature_flags_initialization PASSED [ 39%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_all_flags_registered PASSED [ 40%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_backward_compatibility_mock_camera SKIPPED [ 40%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_prefixed_env_vars_take_precedence PASSED [ 40%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_backward_compatibility_octoprint_compatibility PASSED [ 41%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_prefixed_octoprint_env_var_takes_precedence PASSED [ 41%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_flag_defaults PASSED [ 41%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_parse_bool_variations PASSED [ 42%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_unknown_flag_raises_error PASSED [ 42%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_get_flags_by_category PASSED [ 42%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_get_flag_info PASSED [ 43%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_get_flag_info_unknown PASSED [ 43%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_is_flag_enabled_convenience_function PASSED [ 43%]
tests/test_feature_flags.py::TestFeatureFlagRegistry::test_backward_compat_cors_not_mapped PASSED [ 44%]
tests/test_feature_flags.py::TestFeatureFlagsIntegration::test_main_imports_feature_flags PASSED [ 44%]
tests/test_feature_flags.py::TestFeatureFlagsIntegration::test_feature_flags_loaded_in_main PASSED [ 44%]
tests/test_feature_flags.py::TestFeatureFlagsAPI::test_feature_flags_api_endpoint_exists PASSED [ 45%]
tests/test_integration.py::test_startup_sequence_markers PASSED          [ 45%]
tests/test_integration.py::test_error_recovery_paths[Permission denied handling-markers0] PASSED [ 45%]
tests/test_integration.py::test_error_recovery_paths[RuntimeError handling-markers1] PASSED [ 46%]
tests/test_integration.py::test_error_recovery_paths[General exception handling-markers2] PASSED [ 46%]
tests/test_integration.py::test_error_recovery_paths[Cleanup on error-markers3] PASSED [ 46%]
tests/test_integration.py::test_health_endpoints_present[/health-markers0] PASSED [ 47%]
tests/test_integration.py::test_health_endpoints_present[/ready-markers1] FAILED [ 47%]
tests/test_integration.py::test_health_endpoints_present[/metrics-markers2] FAILED [ 47%]
tests/test_integration.py::test_metrics_collection[Frame count tracking-self._frame_count += 1-pi_camera_in_docker/modes/webcam.py] SKIPPED [ 48%]
tests/test_integration.py::test_metrics_collection[FPS calculation-current_fps = stats.snapshot()-pi_camera_in_docker/modes/webcam.py] SKIPPED [ 48%]
tests/test_integration.py::test_metrics_collection[Frame timing-self._frame_times_monotonic-pi_camera_in_docker/modes/webcam.py] SKIPPED [ 48%]
tests/test_integration.py::test_metrics_collection[Status endpoint-get_stream_status(stream_stats, config-pi_camera_in_docker/main.py] SKIPPED [ 49%]
tests/test_integration.py::test_metrics_collection[Uptime tracking-app.start_time_monotonic-pi_camera_in_docker/main.py] SKIPPED [ 49%]
tests/test_integration.py::test_device_security_explicit_devices SKIPPED [ 49%]
tests/test_integration.py::test_device_security_no_new_privileges SKIPPED [ 50%]
tests/test_integration.py::test_udev_mount_read_only SKIPPED (docker-
compose.yaml not found)                                                  [ 50%]
tests/test_integration.py::test_camera_detection_error_handling SKIPPED  [ 50%]
tests/test_integration.py::test_setup_generator_handles_v4l_subdev_devices PASSED [ 51%]
tests/test_management_api.py::test_api_status_ignores_api_test_mode_when_lock_is_missing PASSED [ 51%]
tests/test_management_api.py::test_api_status_returns_current_api_test_scenario_when_inactive PASSED [ 51%]
tests/test_management_api.py::test_settings_changes_endpoint_compares_resolution_values PASSED [ 52%]
tests/test_management_api.py::test_settings_changes_endpoint_handles_invalid_resolution_env PASSED [ 52%]
tests/test_management_api.py::test_settings_changes_endpoint_handles_invalid_numeric_env PASSED [ 52%]
tests/test_management_api.py::test_settings_patch_response_reflects_persisted_state PASSED [ 53%]
tests/test_management_api.py::test_settings_patch_requires_restart_response_reflects_persisted_state PASSED [ 53%]
tests/test_management_api.py::test_settings_endpoint_returns_effective_runtime_values PASSED [ 53%]
tests/test_management_api.py::test_settings_patch_concurrent_overlapping_updates_are_merged PASSED [ 54%]
tests/test_management_api.py::test_node_crud_and_overview PASSED         [ 54%]
tests/test_management_api.py::test_validation_and_transport_errors PASSED [ 54%]
tests/test_management_api.py::test_create_node_rejects_unmigratable_legacy_basic_auth PASSED [ 55%]
tests/test_management_api.py::test_ssrf_protection_blocks_local_targets PASSED [ 55%]
tests/test_management_api.py::test_corrupted_registry_file_returns_500_error_payload PASSED [ 55%]
tests/test_management_api.py::test_ssrf_protection_blocks_ipv6_mapped_loopback PASSED [ 56%]
tests/test_management_api.py::test_ssrf_protection_blocks_metadata_ip_literal PASSED [ 56%]
tests/test_management_api.py::test_docker_transport_allows_any_valid_token PASSED [ 56%]
tests/test_management_api.py::test_update_node_returns_404_when_node_disappears_during_update PASSED [ 57%]
tests/test_management_api.py::test_discovery_announce_creates_then_updates_node PASSED [ 57%]
tests/test_management_api.py::test_discovery_announce_parallel_requests_do_not_duplicate_error PASSED [ 57%]
tests/test_management_api.py::test_discovery_announce_requires_bearer_token PASSED [ 58%]
tests/test_management_api.py::test_discovery_announce_blocks_private_ip_without_opt_in PASSED [ 58%]
tests/test_management_api.py::test_discovery_announce_allows_private_ip_with_opt_in PASSED [ 58%]
tests/test_management_api.py::test_discovery_announce_validates_payload PASSED [ 59%]
tests/test_management_api.py::test_discovery_approval_endpoint PASSED    [ 59%]
tests/test_management_api.py::test_build_headers_for_bearer_auth_with_token PASSED [ 60%]
tests/test_management_api.py::test_request_json_sends_bearer_auth_header_for_node_probes PASSED [ 60%]
tests/test_management_api.py::test_build_headers_for_bearer_auth_without_token_returns_empty_headers PASSED [ 60%]
tests/test_management_api.py::test_build_headers_for_non_bearer_auth_returns_empty_headers PASSED [ 61%]
tests/test_management_api.py::test_node_status_returns_node_unauthorized_when_upstream_rejects_token PASSED [ 61%]
tests/test_management_api.py::test_node_status_succeeds_when_upstream_token_is_accepted PASSED [ 61%]
tests/test_management_api.py::test_node_status_returns_node_api_mismatch_when_status_endpoint_missing PASSED [ 62%]
tests/test_management_api.py::test_node_status_maps_503_payload_without_error_envelope PASSED [ 62%]
tests/test_management_api.py::test_management_routes_require_authentication PASSED [ 62%]
tests/test_management_api.py::test_node_status_maps_invalid_upstream_payload_to_controlled_error PASSED [ 63%]
tests/test_management_api.py::test_node_action_forwards_restart_and_unsupported_action_payload PASSED [ 63%]
tests/test_management_api.py::test_node_action_maps_invalid_upstream_payload_to_controlled_error PASSED [ 63%]
tests/test_management_api.py::test_create_node_migrates_legacy_auth_with_token PASSED [ 64%]
tests/test_management_api.py::test_request_json_uses_vetted_resolved_ip_and_preserves_host_header PASSED [ 64%]
tests/test_management_api.py::test_request_json_retries_next_vetted_address_when_first_connection_fails PASSED [ 64%]
tests/test_management_api.py::test_request_json_maps_name_resolution_failure_to_dns_category PASSED [ 65%]
tests/test_management_api.py::test_request_json_rejects_blocked_ip_in_resolved_set PASSED [ 65%]
tests/test_management_api.py::test_request_json_maps_timeout_failure PASSED [ 65%]
tests/test_management_api.py::test_request_json_maps_connection_refused_or_reset PASSED [ 66%]
tests/test_management_api.py::test_request_json_maps_tls_failure PASSED  [ 66%]
tests/test_management_api.py::test_request_json_https_uses_hostname_for_tls_and_pins_vetted_ip PASSED [ 66%]
tests/test_management_api.py::test_node_status_reports_connectivity_details PASSED [ 67%]
tests/test_management_api.py::test_webcam_api_status_contract_shape_reports_required_fields PASSED [ 67%]
tests/test_management_api.py::test_webcam_api_status_contract_shape_with_auth PASSED [ 67%]
tests/test_management_api.py::test_node_action_passthrough_for_api_test_management_actions PASSED [ 68%]
tests/test_management_api.py::test_diagnose_includes_structured_status_and_codes PASSED [ 68%]
tests/test_management_api.py::test_diagnose_recommendations_keep_backward_compatible_guidance PASSED [ 68%]
tests/test_management_mode.py::test_management_mode_boots_without_camera SKIPPED [ 69%]
tests/test_management_mode.py::test_webcam_mode_env_validation_and_startup SKIPPED [ 69%]
tests/test_management_mode.py::test_root_serves_management_template_in_management_mode PASSED [ 69%]
tests/test_management_mode.py::test_root_serves_stream_template_in_webcam_mode PASSED [ 70%]
tests/test_management_mode.py::test_api_config_returns_render_config_shape_in_management_mode PASSED [ 70%]
tests/test_management_mode.py::test_api_config_returns_webcam_connection_counts PASSED [ 70%]
tests/test_management_mode.py::test_api_config_webcam_includes_render_config_keys_and_defaulted_values PASSED [ 71%]
tests/test_management_mode.py::test_api_config_management_includes_render_config_keys_and_defaulted_values PASSED [ 71%]
tests/test_management_mode.py::test_request_logging_levels PASSED        [ 71%]
tests/test_management_mode.py::test_webcam_control_plane_endpoints_do_not_require_auth_when_token_unset PASSED [ 72%]
tests/test_management_mode.py::test_webcam_control_plane_endpoints_require_valid_bearer_when_token_set PASSED [ 72%]
tests/test_management_mode.py::test_webcam_api_test_mode_transitions_and_status_contract PASSED [ 72%]
tests/test_management_mode.py::test_webcam_status_contract_reports_degraded_until_stream_is_fresh PASSED [ 73%]
tests/test_management_mode.py::test_webcam_stream_and_snapshot_routes_are_not_protected_by_control_plane_auth PASSED [ 73%]
tests/test_management_mode.py::test_webcam_action_route_requires_auth_and_returns_contract PASSED [ 73%]
tests/test_node_registry.py::test_update_node_raises_keyerror_when_target_missing PASSED [ 74%]
tests/test_node_registry.py::test_update_node_detects_id_collision PASSED [ 74%]
tests/test_node_registry.py::test_create_node_rejects_basic_auth_without_convertible_token PASSED [ 74%]
tests/test_node_registry.py::test_create_node_migrates_legacy_auth_with_token PASSED [ 75%]
tests/test_node_registry.py::test_create_node_requires_bearer_token PASSED [ 75%]
tests/test_node_registry.py::test_load_migrates_legacy_auth_from_registry_file PASSED [ 75%]
tests/test_node_registry.py::test_load_rejects_unmigratable_legacy_auth PASSED [ 76%]
tests/test_node_registry.py::test_load_raises_validation_error_for_corrupted_registry_json PASSED [ 76%]
tests/test_node_registry.py::test_upsert_node_is_atomic_for_concurrent_creates PASSED [ 76%]
tests/test_parallel_containers.py::test_webcam_health PASSED             [ 77%]
tests/test_parallel_containers.py::test_webcam_ready PASSED              [ 77%]
tests/test_parallel_containers.py::test_webcam_metrics PASSED            [ 77%]
tests/test_parallel_containers.py::test_management_health PASSED         [ 78%]
tests/test_parallel_containers.py::test_management_list_nodes PASSED     [ 78%]
tests/test_parallel_containers.py::test_management_register_node PASSED  [ 78%]
tests/test_parallel_containers.py::test_management_query_node_ssrf_protection PASSED [ 79%]
tests/test_parallel_containers.py::test_management_overview PASSED       [ 79%]
tests/test_phase1_components.py::TestStructuredLogging::test_get_correlation_id_from_request_context PASSED [ 80%]
tests/test_phase1_components.py::TestStructuredLogging::test_get_correlation_id_generates_uuid_when_missing PASSED [ 80%]
tests/test_phase1_components.py::TestStructuredLogging::test_get_correlation_id_caches_in_flask_g PASSED [ 80%]
tests/test_phase1_components.py::TestStructuredLogging::test_log_event_structures_data PASSED [ 81%]
tests/test_phase1_components.py::TestStructuredLogging::test_log_error_structures_error_data PASSED [ 81%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_resolution_valid PASSED [ 81%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_resolution_invalid_format PASSED [ 82%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_resolution_out_of_range PASSED [ 82%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_integer_range_valid PASSED [ 82%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_integer_range_out_of_range PASSED [ 83%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_integer_range_wrong_type PASSED [ 83%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_float_range_valid PASSED [ 83%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_float_range_out_of_range PASSED [ 84%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_app_mode_valid PASSED [ 84%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_app_mode_invalid PASSED [ 84%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_url_valid PASSED [ 85%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_url_invalid_scheme PASSED [ 85%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_bearer_token_valid PASSED [ 85%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_bearer_token_too_short PASSED [ 86%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_discovery_config_enabled_complete PASSED [ 86%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_discovery_config_missing_url PASSED [ 86%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_discovery_config_disabled_partial PASSED [ 87%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_all_config_valid_webcam PASSED [ 87%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_all_config_valid_management PASSED [ 87%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_all_config_invalid_resolution PASSED [ 88%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_settings_patch_package_import_path PASSED [ 88%]
tests/test_phase1_components.py::TestConfigValidator::test_validate_all_config_discovery_enabled_invalid PASSED [ 88%]
tests/test_phase1_components.py::TestRateLimiting::test_rate_limiting_endpoint_has_decorator PASSED [ 89%]
tests/test_phase1_components.py::TestCorrelationIdIntegration::test_correlation_id_middleware_installed PASSED [ 89%]
tests/test_phase1_components.py::TestCorrelationIdIntegration::test_correlation_id_in_logs_structure PASSED [ 89%]
tests/test_phase1_components.py::TestConfigValidationHints::test_resolution_error_includes_hint PASSED [ 90%]
tests/test_phase1_components.py::TestConfigValidationHints::test_discovery_config_error_includes_hint PASSED [ 90%]
tests/test_pykms_import.py::test_module_not_found_scenario SKIPPED       [ 90%]
tests/test_pykms_import.py::test_attribute_error_scenario SKIPPED (could
not import 'picamera2': No module named 'picamera2')                     [ 91%]
tests/test_runtime_config.py::test_get_effective_settings_payload_uses_single_persisted_snapshot PASSED [ 91%]
tests/test_units.py::test_check_device_availability_logs_preflight_with_nodes_present PASSED [ 91%]
tests/test_units.py::test_check_device_availability_does_not_warn_when_video_nodes_exist PASSED [ 92%]
tests/test_units.py::test_check_device_availability_warns_when_video_nodes_missing PASSED [ 92%]
tests/test_units.py::test_check_device_availability_warns_when_no_camera_nodes_detected SKIPPED [ 92%]
tests/test_units.py::test_flask_routes PASSED                            [ 93%]
tests/test_units.py::test_dockerfile_has_flask PASSED                    [ 93%]
tests/test_units.py::test_resolution_parsing[1920x1080-expected0] PASSED [ 93%]
tests/test_units.py::test_resolution_parsing[640x480-expected1] PASSED   [ 94%]
tests/test_units.py::test_resolution_parsing[1280x720-expected2] PASSED  [ 94%]
tests/test_units.py::test_fps_parsing[30-30] PASSED                      [ 94%]
tests/test_units.py::test_fps_parsing[60-60] PASSED                      [ 95%]
tests/test_units.py::test_fps_parsing[0-0] PASSED                        [ 95%]
tests/test_units.py::test_fps_parsing[120-120] PASSED                    [ 95%]
tests/test_units.py::test_streaming_output_class PASSED                  [ 96%]
tests/test_units.py::test_logging_configuration PASSED                   [ 96%]
tests/test_units.py::test_healthcheck_url_validation_allows_valid_hostname PASSED [ 96%]
tests/test_units.py::test_get_camera_info_prefers_module_level_global_camera_info SKIPPED [ 97%]
tests/test_units.py::test_get_camera_info_falls_back_to_class_method SKIPPED [ 97%]
tests/test_units.py::test_run_webcam_mode_logs_device_inventory_when_no_cameras_detected SKIPPED [ 97%]
tests/test_units.py::test_shutdown_camera_clears_recording_started_for_real_camera_path SKIPPED [ 98%]
tests/test_units.py::test_shutdown_updates_ready_metrics_and_api_status_immediately PASSED [ 98%]
tests/test_units.py::test_run_webcam_mode_camera_detection_supports_both_global_camera_info_modes SKIPPED [ 98%]
tests/test_units.py::test_register_middleware_keeps_cors_disabled_when_feature_off PASSED [ 99%]
tests/test_units.py::test_register_middleware_applies_wildcard_cors_policy_from_config PASSED [ 99%]
tests/test_units.py::test_register_middleware_applies_explicit_cors_origins_from_config PASSED [100%]

=================================== FAILURES ===================================
________________ test_health_endpoints_present[/ready-markers1] ________________
tests/test_integration.py:71: in test_health_endpoints_present
    assert marker in code, f"Missing marker for {endpoint}: {marker}"
E   AssertionError: Missing marker for /ready: not_ready
E   assert 'not_ready' in '#!/usr/bin/python3\n\nimport io\nimport logging\nimport os\nimport signal\nimport time\nfrom datetime import datetime, timezone\nfrom pathlib import Path  # Moved here\nfrom threading import Event, RLock, Thread\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import Flask, g, jsonify, render_template, request\nfrom flask_cors import CORS\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom .application_settings import ApplicationSettings\nfrom .cat_gif_generator import CatGifGenerator\nfrom .config_validator import ConfigValidationError, validate_all_config\nfrom .discovery import DiscoveryAnnouncer, build_discovery_payload\nfrom .feature_flags import FeatureFlags, get_feature_flags, is_flag_enabled\nfrom .logging_config import configure_logging\nfrom .management_api import register_management_routes\nfrom .modes.webcam import (\n    ConnectionTracker,\n    FrameBuffer,\n    StreamStats,\n    get_stream_status,\n    import_camera_components,\n    register_management_camera_error_routes,\n    register_webcam_routes,\n)\nfrom .runtime_config import (\n    load_env_config,\n    merge_config_with_settings,\n)\n\n\n# Conditional import for picamera2 - not available in all test environments\ntry:\n    from picamera2 import global_camera_info as _picamera2_global_camera_info\nexcept (ModuleNotFoundError, ImportError):\n    # Fallback when picamera2 is not available (e.g., in CI without hardware)\n    def _picamera2_global_camera_info():\n        return []\n\n\nfrom PIL import Image\nfrom werkzeug.serving import make_server\n\nfrom .settings_api import register_settings_routes\nfrom .shared import register_shared_routes, register_webcam_control_plane_auth\n\n\nALLOWED_APP_MODES = {"webcam", "management"}\nDEFAULT_APP_MODE = "webcam"\n\nconfigure_logging()\nlogger = logging.getLogger(__name__)\n\nfeature_flags: FeatureFlags = get_feature_flags()\nfeature_flags.load()\n\n\ndef _redacted_url_for_logs(url: str) -> str:\n    parts = urlsplit(url)\n    host = parts.hostname or ""\n    if parts.port is not None:\n        host = f"{host}:{parts.port}"\n    return urlunsplit((parts.scheme, host, parts.path, "", ""))\n\n\ndef _parse_resolution(resolution_str: str) -> Tuple[int, int]:\n    parts = resolution_str.split("x")\n    if len(parts) != 2:\n        message = f"Invalid resolution format: {resolution_str}"\n        raise ValueError(message)\n    width, height = int(parts[0]), int(parts[1])\n    if width <= 0 or height <= 0 or width > 4096 or height > 4096:\n        message = f"Resolution dimensions out of valid range (1-4096): {width}x{height}"\n        raise ValueError(message)\n    return width, height\n\n\ndef _load_advanced_config() -> Dict[str, Any]:\n    """Load advanced and hardware-specific configuration."""\n    pi3_profile_raw = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    )\n\n    return {\n        "pi3_profile_enabled": pi3_profile_raw.lower() in ("1", "true", "yes"),\n        "mock_camera": is_flag_enabled("MOCK_CAMERA"),\n        "allow_pykms_mock": os.environ.get("ALLOW_PYKMS_MOCK", "false").lower()\n        in ("1", "true", "yes"),\n        "node_registry_path": os.environ.get("NODE_REGISTRY_PATH", "/data/node-registry.json"),\n        "management_auth_token": os.environ.get("MANAGEMENT_AUTH_TOKEN", ""),\n    }\n\n\ndef _load_config() -> Dict[str, Any]:\n    """Load all configuration from environment variables using helper functions."""\n    return load_env_config()\n\n\ndef _merge_config_with_settings(env_config: Dict[str, Any]) -> Dict[str, Any]:\n    return merge_config_with_settings(env_config)\n\n\ndef _detect_camera_devices() -> Dict[str, Any]:\n    """\n    Detect available camera-related device nodes on the system.\n    Returns a dict with detected device information.\n    Failures are logged but don\'t raise exceptions (graceful fallback).\n    """\n    result: Dict[str, Union[bool, List[str]]] = {\n        "has_camera": False,\n        "video_devices": List[str](),\n        "media_devices": List[str](),\n        "v4l_subdev_devices": List[str](),\n        "dma_heap_devices": List[str](),\n        "vchiq_device": False,\n        "dri_device": False,\n    }\n\n    try:\n        # Check DMA heap devices\n        dma_heap_dir = "/dev/dma_heap"\n        if Path(dma_heap_dir).is_dir():\n            try:\n                dma_devices = [f.name for f in Path(dma_heap_dir).iterdir()]\n                result["dma_heap_devices"] = [f"/dev/dma_heap/{d}" for d in dma_devices]\n            except OSError:\n                logger.debug("Could not list /dev/dma_heap directory")\n\n        # Check video devices\n        for i in range(10):\n            video_device = f"/dev/video{i}"\n            if Path(video_device).exists():\n                result["video_devices"].append(video_device)\n\n        # Check media devices\n        for i in range(10):\n            media_device = f"/dev/media{i}"\n            if Path(media_device).exists():\n                result["media_devices"].append(media_device)\n\n        # Check v4l sub-device nodes\n        for i in range(64):\n            subdev_device = f"/dev/v4l-subdev{i}"\n            if Path(subdev_device).exists():\n                result["v4l_subdev_devices"].append(subdev_device)\n\n        # Check VCHIQ\n        if Path("/dev/vchiq").exists():\n            result["vchiq_device"] = True\n\n        # Check DRI (graphics)\n        if Path("/dev/dri").exists():\n            result["dri_device"] = True\n\n        # Set has_camera flag\n        result["has_camera"] = bool(\n            result["video_devices"]\n            or result["media_devices"]\n            or result["v4l_subdev_devices"]\n            or result["vchiq_device"]\n        )\n    except Exception as e:\n        logger.warning(f"Device detection encountered error: {e}")\n\n    return result\n\n\ndef _collect_current_config() -> Dict[str, Any]:\n    """\n    Collect current configuration from environment variables.\n    Returns a simplified config dict for the setup API.\n    """\n    try:\n        resolution = _parse_resolution(os.environ.get("RESOLUTION", "640x480"))\n    except ValueError:\n        resolution = (640, 480)\n\n    try:\n        fps = int(os.environ.get("FPS", "0"))\n    except ValueError:\n        fps = 0\n\n    try:\n        target_fps_str = os.environ.get("TARGET_FPS", "")\n        target_fps = int(target_fps_str) if target_fps_str else None\n    except ValueError:\n        target_fps = None\n\n    try:\n        jpeg_quality = int(os.environ.get("JPEG_QUALITY", "90"))\n        if not 1 <= jpeg_quality <= 100:\n            jpeg_quality = 90\n    except ValueError:\n        jpeg_quality = 90\n\n    try:\n        max_stream_connections = int(os.environ.get("MAX_STREAM_CONNECTIONS", "10"))\n        if not 1 <= max_stream_connections <= 100:\n            max_stream_connections = 10\n    except ValueError:\n        max_stream_connections = 10\n\n    pi3_profile = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    ).lower() in (\n        "1",\n        "true",\n        "yes",\n    )\n    mock_camera = is_flag_enabled("MOCK_CAMERA")\n    cors_origins = os.environ.get("MOTION_IN_OCEAN_CORS_ORIGINS", "")\n    auth_token = os.environ.get("MANAGEMENT_AUTH_TOKEN", "")\n\n    return {\n        "resolution": f"{resolution[0]}x{resolution[1]}",\n        "fps": fps,\n        "target_fps": target_fps,\n        "jpeg_quality": jpeg_quality,\n        "max_connections": max_stream_connections,\n        "pi3_profile": pi3_profile,\n        "mock_camera": mock_camera,\n        "cors_origins": cors_origins,\n        "auth_token": auth_token,\n    }\n\n\ndef _get_setup_presets() -> Dict[str, Dict[str, Any]]:\n    """\n    Return available setup presets with default values.\n    """\n    return {\n        "pi3_low_power": {\n            "name": "Pi3 Low Power",\n            "description": "Optimized for Raspberry Pi 3 with low resource usage",\n            "resolution": "640x480",\n            "fps": 12,\n            "target_fps": 12,\n            "jpeg_quality": 75,\n            "max_connections": 3,\n            "pi3_profile": True,\n            "mock_camera": False,\n        },\n        "pi5_high_quality": {\n            "name": "Pi5 High Quality",\n            "description": "High quality streaming for Raspberry Pi 5",\n            "resolution": "1280x720",\n            "fps": 24,\n            "target_fps": 24,\n            "jpeg_quality": 90,\n            "max_connections": 10,\n            "pi3_profile": False,\n            "mock_camera": False,\n        },\n    }\n\n\ndef _validate_setup_config(config: Dict[str, Any]) -> Tuple[bool, list]:\n    """\n    Validate setup configuration values.\n    Returns (is_valid, list_of_errors).\n    """\n    errors = []\n\n    # Validate resolution\n    if "resolution" in config:\n        try:\n            _parse_resolution(config["resolution"])\n        except ValueError as e:\n            errors.append(f"Resolution: {e!s}")\n\n    # Validate FPS\n    if "fps" in config:\n        fps = config.get("fps", 0)\n        if not isinstance(fps, int) or fps < 0 or fps > 120:\n            errors.append("FPS must be an integer between 0 and 120")\n\n    # Validate target FPS\n    if "target_fps" in config and config["target_fps"] is not None:\n        target_fps = config["target_fps"]\n        if not isinstance(target_fps, int) or target_fps < 1 or target_fps > 120:\n            errors.append("Target FPS must be an integer between 1 and 120 (or null to disable)")\n\n    # Validate JPEG quality\n    if "jpeg_quality" in config:\n        quality = config.get("jpeg_quality", 90)\n        if not isinstance(quality, int) or quality < 1 or quality > 100:\n            errors.append("JPEG Quality must be between 1 and 100")\n\n    # Validate max connections\n    if "max_connections" in config:\n        conns = config.get("max_connections", 10)\n        if not isinstance(conns, int) or conns < 1 or conns > 100:\n            errors.append("Max Connections must be between 1 and 100")\n\n    return len(errors) == 0, errors\n\n\ndef _generate_docker_compose_content(\n    _config: Dict[str, Any], detected_devices: Dict[str, Any]\n) -> str:\n    """\n    Generate docker-compose.yaml content based on configuration and detected devices.\n    """\n    # Base docker-compose with anchors\n    compose = """# Motion In Ocean Docker Compose Configuration\n# Generated by the Set-Up UI\n\nx-motion-in-ocean-common: &motion-in-ocean-common\n  image: ghcr.io/cyanautomation/motioninocean:latest\n  platform: linux/arm64\n  restart: unless-stopped\n  env_file: ./.env\n  security_opt:\n    - no-new-privileges:true\n  stop_grace_period: 30s\n  logging:\n    driver: json-file\n    options:\n      max-size: "10m"\n      max-file: "3"\n\nx-motion-in-ocean-camera: &motion-in-ocean-camera\n  volumes:\n    - /run/udev:/run/udev:ro\n  devices:\n"""\n\n    # Add detected devices\n    if detected_devices.get("dma_heap_devices"):\n        for device in detected_devices["dma_heap_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("vchiq_device"):\n        compose += "    - /dev/vchiq:/dev/vchiq\\n"\n\n    if detected_devices.get("video_devices"):\n        for device in detected_devices["video_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("media_devices"):\n        for device in detected_devices["media_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("v4l_subdev_devices"):\n        for device in detected_devices["v4l_subdev_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("dri_device"):\n        compose += "    - /dev/dri:/dev/dri\\n"\n\n    compose += """  group_add:\n    - video\n  device_cgroup_rules:\n    - "c 253:* rmw"\n    - "c 511:* rmw"\n    - "c 81:* rmw"\n    - "c 250:* rmw"\n\nservices:\n  motion-in-ocean:\n    <<: [*motion-in-ocean-common, *motion-in-ocean-camera]\n    container_name: motion-in-ocean\n    environment:\n      TZ: ${TZ}\n      APP_MODE: ${MOTION_IN_OCEAN_MODE:-webcam}\n      RESOLUTION: ${MOTION_IN_OCEAN_RESOLUTION}\n      FPS: ${MOTION_IN_OCEAN_FPS}\n      TARGET_FPS: ${MOTION_IN_OCEAN_TARGET_FPS:-}\n      JPEG_QUALITY: ${MOTION_IN_OCEAN_JPEG_QUALITY}\n      MAX_STREAM_CONNECTIONS: ${MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS:-2}\n      # Canonical Pi 3 profile toggle consumed by runtime config loading.\n      MOTION_IN_OCEAN_PI3_PROFILE: ${MOTION_IN_OCEAN_PI3_PROFILE:-false}\n      MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY: ${MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY:-false}\n      CORS_ORIGINS: ${MOTION_IN_OCEAN_CORS_ORIGINS}\n      MOCK_CAMERA: ${MOCK_CAMERA:-false}\n      HEALTHCHECK_READY: ${MOTION_IN_OCEAN_HEALTHCHECK_READY:-true}\n    ports:\n      - "${MOTION_IN_OCEAN_BIND_HOST:-127.0.0.1}:${MOTION_IN_OCEAN_PORT:-8000}:8000"\n    volumes:\n      - motion-in-ocean-data:/data\n    healthcheck:\n      test: ["CMD", "python3", "/app/healthcheck.py"]\n      interval: 2m\n      timeout: 10s\n      retries: 3\n      start_period: 2m\n\nvolumes:\n  motion-in-ocean-data:\n    driver: local\n"""\n    return compose\n\n\ndef _generate_env_content(config: Dict[str, Any]) -> str:\n    """\n    Generate .env content based on configuration.\n    """\n    env_lines = [\n        "# Motion In Ocean Environment Configuration",\n        "# Generated by the Set-Up UI",\n        "",\n        "# Timezone",\n        "TZ=UTC",\n        "",\n        "# Application Mode (webcam or management)",\n        "MOTION_IN_OCEAN_MODE=webcam",\n        "",\n        "# Camera Configuration",\n        f"MOTION_IN_OCEAN_RESOLUTION={config.get(\'resolution\', \'640x480\')}",\n        f"MOTION_IN_OCEAN_FPS={config.get(\'fps\', 0)}",\n        f"MOTION_IN_OCEAN_TARGET_FPS={config.get(\'target_fps\', \'\') or \'\'}",\n        f"MOTION_IN_OCEAN_JPEG_QUALITY={config.get(\'jpeg_quality\', 90)}",\n        f"MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS={config.get(\'max_connections\', 10)}",\n        # Canonical Pi 3 profile env variable consumed by runtime config loading.\n        f"MOTION_IN_OCEAN_PI3_PROFILE={\'true\' if config.get(\'pi3_profile\') else \'false\'}",\n        "",\n        "# Features and Integration",\n        "MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY=false",\n        f"MOTION_IN_OCEAN_CORS_ORIGINS={config.get(\'cors_origins\', \'\')}",\n        f"MOCK_CAMERA={\'true\' if config.get(\'mock_camera\') else \'false\'}",\n        "MOTION_IN_OCEAN_HEALTHCHECK_READY=true",\n        "",\n        "# Networking",\n        "MOTION_IN_OCEAN_BIND_HOST=127.0.0.1",\n        "MOTION_IN_OCEAN_PORT=8000",\n        "MOTION_IN_OCEAN_IMAGE_TAG=latest",\n        "",\n        "# Management/Security",\n        f"MANAGEMENT_AUTH_TOKEN={config.get(\'auth_token\', \'\')}",\n        "",\n    ]\n\n    return "\\n".join(env_lines)\n\n\ndef _init_flask_app(_config: Dict[str, Any]) -> Tuple[Flask, Limiter]:\n    """Initialize Flask app and rate limiter."""\n    app = Flask(__name__, static_folder="static", static_url_path="/static")\n    app.start_time_monotonic = time.monotonic()\n\n    limiter = Limiter(\n        app=app,\n        key_func=get_remote_address,\n        default_limits=["100/minute"],\n        storage_uri=os.environ.get("LIMITER_STORAGE_URI", "memory://"),\n    )\n\n    return app, limiter\n\n\ndef _register_middleware(app: Flask, config: Dict[str, Any]) -> None:\n    """Register middleware for correlation ID, logging, and CORS."""\n\n    # Add correlation ID middleware\n    @app.before_request\n    def _add_correlation_id() -> None:\n        g.correlation_id = (\n            request.headers.get("X-Correlation-ID", request.headers.get("x-correlation-id", ""))\n            or None\n        )\n\n    # Ensure correlation ID is returned in response\n    @app.after_request\n    def _inject_correlation_id(response):\n        if hasattr(g, "correlation_id") and g.correlation_id:\n            response.headers["X-Correlation-ID"] = g.correlation_id\n        return response\n\n    _register_request_logging(app)\n\n    if config["cors_enabled"]:\n        cors_origins_config = config.get("cors_origins", "*")\n\n        if isinstance(cors_origins_config, str):\n            parsed_origins = [\n                origin.strip() for origin in cors_origins_config.split(",") if origin.strip()\n            ]\n            cors_origins = (\n                parsed_origins\n                if len(parsed_origins) > 1\n                else (parsed_origins[0] if parsed_origins else "*")\n            )\n        elif isinstance(cors_origins_config, (list, tuple, set)):\n            parsed_origins = [\n                str(origin).strip() for origin in cors_origins_config if str(origin).strip()\n            ]\n            cors_origins = parsed_origins if parsed_origins else "*"\n        else:\n            cors_origins = "*"\n\n        cors_options = {"resources": {r"/*": {"origins": cors_origins}}}\n        if cors_origins == "*":\n            cors_options["send_wildcard"] = True\n\n        CORS(app, **cors_options)\n\n\ndef _init_app_state(config: Dict[str, Any]) -> dict:\n    """Initialize application state dictionary."""\n    return {\n        "app_mode": config["app_mode"],\n        "recording_started": Event(),\n        "shutdown_requested": Event(),\n        "camera_lock": RLock(),\n        "max_frame_age_seconds": config["max_frame_age_seconds"],\n        "picam2_instance": None,\n        "cat_gif_generator": None,\n    }\n\n\ndef _create_base_app(config: Dict[str, Any]) -> Tuple[Flask, Limiter, dict]:\n    # Initialize Flask app and limiter\n    app, limiter = _init_flask_app(config)\n\n    # Register middleware\n    _register_middleware(app, config)\n\n    # Initialize application state\n    state = _init_app_state(config)\n    app.motion_state = state\n    app.motion_config = dict(config)\n    app.application_settings = ApplicationSettings()  # Add settings persistence\n\n    @app.route("/")\n    def index() -> str:\n        if config["app_mode"] == "management":\n            return render_template("management.html")\n        return render_template(\n            "index.html", width=config["resolution"][0], height=config["resolution"][1]\n        )\n\n    @app.route("/api/config")\n    def api_config():\n        def _indicator(state_value: str, label: str, details: str) -> Dict[str, str]:\n            return {\n                "state": state_value,\n                "label": label,\n                "details": details,\n            }\n\n        def _build_health_check(\n            camera_is_active: bool,\n            stream_status: Dict[str, Any],\n            current_connections_count: int,\n            max_connections_count: int,\n        ) -> Dict[str, Dict[str, str]]:\n            last_frame_age_seconds = stream_status.get("last_frame_age_seconds")\n            max_age_seconds = state.get("max_frame_age_seconds", config["max_frame_age_seconds"])\n\n            if camera_is_active:\n                camera_pipeline = _indicator(\n                    "ok",\n                    "Camera pipeline active",\n                    "Camera recording pipeline is active.",\n                )\n            elif state.get("app_mode") == "management":\n                camera_pipeline = _indicator(\n                    "unknown",\n                    "Camera pipeline not required",\n                    "Management mode does not require an active camera pipeline.",\n                )\n            else:\n                camera_pipeline = _indicator(\n                    "fail",\n                    "Camera pipeline inactive",\n                    "Camera recording pipeline is not active.",\n                )\n\n            if last_frame_age_seconds is None:\n                stream_freshness = _indicator(\n                    "unknown",\n                    "Stream freshness unavailable",\n                    "No frame age is currently available to evaluate freshness.",\n                )\n            elif last_frame_age_seconds <= max_age_seconds:\n                stream_freshness = _indicator(\n                    "ok",\n                    "Stream is fresh",\n                    f"Last frame age {last_frame_age_seconds:.2f}s is within the {max_age_seconds:.2f}s threshold.",\n                )\n            else:\n                stream_freshness = _indicator(\n                    "fail",\n                    "Stream is stale",\n                    f"Last frame age {last_frame_age_seconds:.2f}s exceeds the {max_age_seconds:.2f}s threshold.",\n                )\n\n            connection_ratio = (\n                current_connections_count / max_connections_count\n                if max_connections_count > 0\n                else 0.0\n            )\n            if max_connections_count <= 0:\n                connection_capacity = _indicator(\n                    "unknown",\n                    "Connection capacity unavailable",\n                    "Maximum stream connections is not configured.",\n                )\n            elif connection_ratio >= 1.0:\n                connection_capacity = _indicator(\n                    "fail",\n                    "Connection capacity reached",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            elif connection_ratio >= 0.8:\n                connection_capacity = _indicator(\n                    "warn",\n                    "Connection capacity nearing limit",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            else:\n                connection_capacity = _indicator(\n                    "ok",\n                    "Connection capacity healthy",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n\n            expected_real_camera = state.get("app_mode") == "webcam"\n            if config["mock_camera"] and expected_real_camera:\n                mock_mode = _indicator(\n                    "warn",\n                    "Mock camera enabled",\n                    "Mock camera is enabled while webcam mode is active.",\n                )\n            elif config["mock_camera"]:\n                mock_mode = _indicator(\n                    "ok",\n                    "Mock camera enabled",\n                    "Mock camera is enabled for a non-webcam mode.",\n                )\n            else:\n                mock_mode = _indicator(\n                    "ok",\n                    "Real camera mode",\n                    "Mock camera is disabled.",\n                )\n\n            return {\n                "camera_pipeline": camera_pipeline,\n                "stream_freshness": stream_freshness,\n                "connection_capacity": connection_capacity,\n                "mock_mode": mock_mode,\n            }\n\n        if state.get("app_mode") == "webcam":\n            tracker = state.get("connection_tracker")\n            recording_started = state.get("recording_started")\n            stream_stats = state.get("stream_stats")\n\n            current_connections = (\n                tracker.get_count() if isinstance(tracker, ConnectionTracker) else 0\n            )\n            camera_active = isinstance(recording_started, Event) and recording_started.is_set()\n            stream_status = (\n                get_stream_status(stream_stats, config["resolution"])\n                if isinstance(stream_stats, StreamStats)\n                else {"last_frame_age_seconds": None}\n            )\n            uptime_seconds = round(\n                max(\n                    0.0,\n                    time.monotonic() - getattr(app, "start_time_monotonic", 0.0),\n                ),\n                2,\n            )\n        else:\n            current_connections = 0\n            camera_active = False\n            stream_status = {"last_frame_age_seconds": None}\n            uptime_seconds = None\n\n        max_connections = state.get("max_stream_connections", config["max_stream_connections"])\n        health_check = _build_health_check(\n            camera_active,\n            stream_status,\n            current_connections,\n            max_connections,\n        )\n\n        return jsonify(\n            {\n                "camera_settings": {\n                    "resolution": list(config["resolution"]),\n                    "fps": config["fps"],\n                    "target_fps": config["target_fps"],\n                    "jpeg_quality": config["jpeg_quality"],\n                },\n                "stream_control": {\n                    "max_stream_connections": state.get(\n                        "max_stream_connections", config["max_stream_connections"]\n                    ),\n                    "current_stream_connections": current_connections,\n                    "max_frame_age_seconds": state.get(\n                        "max_frame_age_seconds", config["max_frame_age_seconds"]\n                    ),\n                    "cors_origins": config["cors_origins"],\n                },\n                "runtime": {\n                    "camera_active": camera_active,\n                    "mock_camera": config["mock_camera"],\n                    "uptime_seconds": uptime_seconds,\n                },\n                "health_check": health_check,\n                "timestamp": datetime.now(timezone.utc).isoformat(),\n                "app_mode": config["app_mode"],\n            }\n        ), 200\n\n    @app.route("/api/feature-flags")\n    def api_flags():\n        return jsonify(feature_flags.get_all_flags()), 200\n\n    @app.route("/api/setup/templates", methods=["GET"])\n    def api_setup_templates():\n        """Return setup templates, current config, detected devices, and constraints."""\n        try:\n            current_config = _collect_current_config()\n            detected_devices = _detect_camera_devices()\n            presets = _get_setup_presets()\n\n            return jsonify(\n                {\n                    "current_config": current_config,\n                    "available_presets": presets,\n                    "detected_devices": detected_devices,\n                    "constraints": {\n                        "resolution_examples": ["640x480", "1280x720", "1920x1080"],\n                        "fps_range": [0, 120],\n                        "jpeg_quality_range": [1, 100],\n                        "max_connections_range": [1, 100],\n                    },\n                    "app_mode": config["app_mode"],\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup templates endpoint failed")\n            return jsonify({"error": f"Failed to load setup templates: {e!s}"}), 500\n\n    @app.route("/api/setup/validate", methods=["POST"])\n    def api_setup_validate():\n        """Validate setup configuration values."""\n        try:\n            data = request.get_json() or {}\n            is_valid, errors = _validate_setup_config(data)\n\n            return jsonify(\n                {\n                    "valid": is_valid,\n                    "errors": errors,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup validation endpoint failed")\n            return jsonify({"valid": False, "errors": [f"Validation error: {e!s}"]}), 200\n\n    @app.route("/api/setup/generate", methods=["POST"])\n    def api_setup_generate():\n        """Generate docker-compose.yaml and .env files based on provided configuration."""\n        try:\n            data = request.get_json() or {}\n\n            # Validate first\n            is_valid, errors = _validate_setup_config(data)\n            if not is_valid:\n                error_msg = "; ".join(errors)\n                logger.warning(f"Setup generation validation failed: {error_msg}")\n                return jsonify({"error": f"Configuration invalid: {error_msg}"}), 400\n\n            # Detect devices\n            detected_devices = _detect_camera_devices()\n\n            # Generate files\n            docker_compose_content = _generate_docker_compose_content(data, detected_devices)\n            env_content = _generate_env_content(data)\n\n            return jsonify(\n                {\n                    "docker_compose_yaml": docker_compose_content,\n                    "env_content": env_content,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup generation endpoint failed")\n            return jsonify({"error": f"Failed to generate configuration: {e!s}"}), 500\n\n    # NOTE: The following endpoints are defined in shared.py via register_shared_routes:\n\n\n\n\n    return app, limiter, state\n\n\ndef _register_request_logging(app: Flask) -> None:\n    health_endpoints = {"/health", "/ready"}\n\n    @app.before_request\n    def _track_request_start() -> None:\n        g.request_started_monotonic = time.monotonic()\n\n    @app.after_request\n    def _log_request(response):\n        request_started = getattr(g, "request_started_monotonic", None)\n        latency_ms = 0.0\n        if request_started is not None:\n            latency_ms = (time.monotonic() - request_started) * 1000\n\n        correlation_id = getattr(g, "correlation_id", None) or "none"\n        level = logging.DEBUG if request.path in health_endpoints else logging.INFO\n        logger.log(\n            level,\n            "request correlation_id=%s method=%s path=%s status=%s latency_ms=%.1f",\n            correlation_id,\n            request.method,\n            request.path,\n            response.status_code,\n            latency_ms,\n        )\n        return response\n\n\ndef create_management_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "management"\n    app, limiter, state = _create_base_app(cfg)\n    # Routes registered by these functions:\n    # @app.route("/")  # defined in _create_base_app\n    # @app.route("/health")  # registered in register_shared_routes (shared.py)\n    # @app.route("/ready")  # registered in register_shared_routes (shared.py)\n    register_shared_routes(app, state)\n    register_settings_routes(app)  # Add settings management API\n    register_management_camera_error_routes(app)\n    register_management_routes(\n        app,\n        cfg["node_registry_path"],\n        auth_token=cfg["management_auth_token"],\n        limiter=limiter,\n    )\n    # Log management mode startup configuration\n    logger.info(\n        "management_mode_initialized: auth_required=%s, registry_path=%s",\n        bool(cfg["management_auth_token"]),\n        cfg["node_registry_path"],\n    )\n    return app\n\n\ndef create_webcam_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "webcam"\n    app, _limiter, state = _create_base_app(cfg)\n\n    stream_stats = StreamStats()\n    output = FrameBuffer(stream_stats, target_fps=cfg["target_fps"])\n    state.update(\n        {\n            "output": output,\n            "stream_stats": stream_stats,\n            "connection_tracker": ConnectionTracker(),\n            "max_stream_connections": cfg["max_stream_connections"],\n            "api_test": {\n                "enabled": cfg["api_test_mode_enabled"],\n                "active": cfg["api_test_mode_enabled"],\n                "current_state_index": 0,\n                "scenario_list": [],\n                "last_transition_monotonic": time.monotonic(),\n                "cycle_interval_seconds": cfg["api_test_cycle_interval_seconds"],\n                "lock": RLock(),\n            },\n            "discovery_announcer": None,\n        }\n    )\n\n    default_api_test_scenarios = [\n        {\n            "status": "ok",\n            "stream_available": True,\n            "camera_active": True,\n            "fps": 24.0,\n            "connections": {"current": 1, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": True,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": False,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n    ]\n\n    def _get_api_test_status_override(\n        uptime_seconds: float, max_connections: int\n    ) -> Optional[Dict[str, Any]]:\n        api_test_state = state.get("api_test")\n        if not api_test_state or not api_test_state.get("enabled"):\n            return None\n\n        lock = api_test_state.get("lock")\n        if not lock:\n            return None\n\n        with lock:\n            scenario_list = api_test_state.get("scenario_list") or default_api_test_scenarios\n            if not api_test_state.get("scenario_list"):\n                api_test_state["scenario_list"] = scenario_list\n\n            interval = api_test_state.get("cycle_interval_seconds", 5.0)\n            now = time.monotonic()\n\n            if (\n                api_test_state.get("active")\n                and interval > 0\n                and now - api_test_state.get("last_transition_monotonic", now) >= interval\n            ):\n                api_test_state["current_state_index"] = (\n                    api_test_state.get("current_state_index", 0) + 1\n                ) % len(scenario_list)\n                api_test_state["last_transition_monotonic"] = now\n\n            current_state_index = api_test_state.get("current_state_index", 0) % len(scenario_list)\n            scenario = scenario_list[current_state_index]\n            state_name = scenario.get("status", f"state-{current_state_index}")\n\n            next_transition_seconds = None\n            if api_test_state.get("active") and interval > 0:\n                elapsed = max(0.0, now - api_test_state.get("last_transition_monotonic", now))\n                next_transition_seconds = round(max(0.0, interval - elapsed), 3)\n\n        return {\n            "status": scenario["status"],\n            "app_mode": state["app_mode"],\n            "stream_available": scenario["stream_available"],\n            "camera_active": scenario["camera_active"],\n            "uptime_seconds": uptime_seconds,\n            "fps": scenario["fps"],\n            "connections": {\n                "current": scenario["connections"]["current"],\n                "max": max_connections,\n            },\n            "timestamp": datetime.now(timezone.utc).isoformat(),\n            "api_test": {\n                "enabled": api_test_state.get("enabled", False),\n                "active": api_test_state.get("active", False),\n                "state_index": current_state_index,\n                "state_name": state_name,\n                "next_transition_seconds": next_transition_seconds,\n            },\n        }\n\n    register_shared_routes(\n        app,\n        state,\n        get_stream_status=lambda: get_stream_status(stream_stats, cfg["resolution"]),\n        get_api_test_status_override=_get_api_test_status_override,\n    )\n    register_settings_routes(app)  # Add settings management API\n    register_webcam_control_plane_auth(\n        app,\n        cfg["management_auth_token"],\n        app_mode_provider=lambda: state["app_mode"],\n    )\n    # Routes registered by register_webcam_routes:\n    # @app.route("/stream.mjpg")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam/")  # registered in register_webcam_routes (modes/webcam.py)\n    register_webcam_routes(app, state, is_flag_enabled=is_flag_enabled)\n    _run_webcam_mode(state, cfg)\n\n    if cfg["discovery_enabled"]:\n        if not cfg["discovery_token"]:\n            logger.warning("Discovery enabled but DISCOVERY_TOKEN is empty; announcer disabled")\n        else:\n            try:\n                discovery_cfg = {\n                    "discovery_node_id": cfg["discovery_node_id"],\n                    "discovery_base_url": cfg["base_url"],\n                }\n                payload = build_discovery_payload(discovery_cfg)\n                announcer = DiscoveryAnnouncer(\n                    management_url=cfg["discovery_management_url"],\n                    token=cfg["discovery_token"],\n                    interval_seconds=cfg["discovery_interval_seconds"],\n                    node_id=payload["node_id"],\n                    payload=payload,\n                    shutdown_event=state["shutdown_requested"],\n                )\n                announcer.start()\n                state["discovery_announcer"] = announcer\n                logger.info(\n                    "discovery_announcer_started: node_id=%s management_url=%s interval_seconds=%.1f",\n                    payload["node_id"],\n                    _redacted_url_for_logs(cfg["discovery_management_url"]),\n                    cfg["discovery_interval_seconds"],\n                )\n            except Exception:\n                logger.exception("Failed to initialize discovery announcer")\n    return app\n\n\ndef create_app_from_env() -> Flask:\n    cfg = _load_config()\n    try:\n        validate_all_config(cfg)\n    except ConfigValidationError as e:\n        error_msg = str(e)\n        if e.hint:\n            error_msg += f" ({e.hint})"\n        logger.error("Configuration validation failed: %s", error_msg)\n        raise ValueError(error_msg) from e\n\n    app = create_management_app(cfg) if cfg["app_mode"] == "management" else create_webcam_app(cfg)\n    logger.info("Application started in %s mode", cfg["app_mode"])\n    return app\n\n\ndef _check_device_availability(cfg: Dict[str, Any]) -> None:\n    """Validate that required camera device nodes exist before initialization."""\n    if cfg["mock_camera"]:\n        return\n\n    required_devices = ["/dev/vchiq"]\n    device_patterns = {\n        "video": range(10),  # /dev/video0 through /dev/video9\n        "media": range(10),  # /dev/media0 through /dev/media9\n        "v4l_subdev": range(64),  # /dev/v4l-subdev0 through /dev/v4l-subdev63\n        "dma_heap": ["system", "linux,cma"],  # Common dma_heap device names\n    }\n\n    device_pattern_display = {\n        "video": "/dev/video*",\n        "media": "/dev/media*",\n        "v4l_subdev": "/dev/v4l-subdev*",\n        "dma_heap": "/dev/dma_heap/*",\n    }\n\n    discovered_nodes = {\n        "video": [\n            Path(f"/dev/video{i}")\n            for i in device_patterns["video"]\n            if Path(f"/dev/video{i}").exists()\n        ],\n        "media": [\n            Path(f"/dev/media{i}")\n            for i in device_patterns["media"]\n            if Path(f"/dev/media{i}").exists()\n        ],\n        "v4l_subdev": [\n            Path(f"/dev/v4l-subdev{i}")\n            for i in device_patterns["v4l_subdev"]\n            if Path(f"/dev/v4l-subdev{i}").exists()\n        ],\n        "dma_heap": [\n            Path(f"/dev/dma_heap/{name}")\n            for name in device_patterns["dma_heap"]\n            if Path(f"/dev/dma_heap/{name}").exists()\n        ],\n    }\n\n    preflight_summary = {\n        "counts": {name: len(paths) for name, paths in discovered_nodes.items()},\n        "samples": {name: paths[:3] for name, paths in discovered_nodes.items()},\n    }\n    logger.info("Camera preflight device summary: %s", preflight_summary)\n\n    missing_critical = [device for device in required_devices if not Path(device).exists()]\n\n    if missing_critical:\n        logger.warning(\n            "Critical camera devices not found: %s. "\n            "Check device mappings in docker-compose.yaml and run ./detect-devices.sh on host.",\n            ", ".join(missing_critical),\n        )\n\n    if not (\n        discovered_nodes["video"] or discovered_nodes["media"] or discovered_nodes["v4l_subdev"]\n    ):\n        logger.warning(\n            "No /dev/video*, /dev/media*, or /dev/v4l-subdev* nodes were detected during preflight. "\n            "Camera enumeration is likely to fail in this container. "\n            "Verify host camera drivers and container device mappings."\n        )\n    elif not discovered_nodes["video"]:\n        missing_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if not discovered_nodes[group_name]\n        ]\n        present_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if discovered_nodes[group_name]\n        ]\n        logger.warning(\n            "Camera device preflight found partial node availability. Present groups: %s. "\n            "Missing groups: %s. Streaming is likely unavailable; verify device mappings and driver state.",\n            ", ".join(present_node_groups),\n            ", ".join(missing_node_groups),\n        )\n\n\ndef _shutdown_camera(state: Dict[str, Any]) -> None:\n    shutdown_requested: Optional[Event] = state.get("shutdown_requested")\n    if shutdown_requested is not None:\n        shutdown_requested.set()\n\n    recording_started: Optional[Event] = state.get("recording_started")\n    if recording_started is not None:\n        recording_started.clear()\n\n    camera_lock: Optional[RLock] = state.get("camera_lock")\n    if camera_lock is None:\n        logger.warning("Camera lock not found in shutdown state")\n        return\n\n    with camera_lock:\n        picam2_instance = state.get("picam2_instance")\n        if picam2_instance is None:\n            return\n\n        try:\n            if getattr(picam2_instance, "started", False):\n                picam2_instance.stop_recording()  # stop_recording marker\n        except Exception:\n            logger.exception("Failed to stop camera recording during shutdown")\n        finally:\n            state["picam2_instance"] = None\n\n\ndef _get_camera_info(picamera2_cls: Any) -> Tuple[list, str]:\n    try:\n        return _picamera2_global_camera_info(), "picamera2.global_camera_info"\n    except (ImportError, AttributeError, NameError):\n        logger.debug(\n            "picamera2.global_camera_info import unavailable; falling back to Picamera2 class method"\n        )\n\n    class_global_camera_info = getattr(picamera2_cls, "global_camera_info", None)\n    if callable(class_global_camera_info):\n        try:\n            return class_global_camera_info(), "Picamera2.global_camera_info"\n        except Exception:\n            logger.debug("Picamera2.global_camera_info call failed at runtime")\n\n    logger.warning(\n        "Unable to query camera inventory from picamera2. Proceeding with empty camera list. "\n        "If camera detection fails, verify the installed picamera2 version supports global_camera_info."\n    )\n    return [], "none"\n\n\ndef _init_mock_camera_frames(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize mock camera frame generation."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n\n    if cfg["cat_gif_enabled"]:\n        # Use cat GIF streaming mode\n        cat_generator = CatGifGenerator(\n            api_url=cfg["cataas_api_url"],\n            resolution=cfg["resolution"],\n            jpeg_quality=cfg["jpeg_quality"],\n            target_fps=cfg["fps"] if cfg["fps"] > 0 else 10,\n            cache_ttl_seconds=cfg["cat_gif_cache_ttl_seconds"],\n        )\n        state["cat_gif_generator"] = cat_generator\n\n        def generate_cat_gif_frames() -> None:\n            recording_started.set()\n            try:\n                for frame in cat_generator.generate_frames():\n                    if shutdown_requested.is_set():\n                        break\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_cat_gif_frames, daemon=True).start()\n    else:\n        # Use classic black frame mock mode\n        fallback = Image.new("RGB", cfg["resolution"], color=(0, 0, 0))\n        buf = io.BytesIO()\n        fallback.save(buf, format="JPEG", quality=cfg["jpeg_quality"])\n        frame = buf.getvalue()\n\n        def generate_mock_frames() -> None:\n            recording_started.set()\n            try:\n                while not shutdown_requested.is_set():\n                    time.sleep(1 / (cfg["fps"] if cfg["fps"] > 0 else 10))\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_mock_frames, daemon=True).start()\n\n\ndef _init_real_camera(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize real camera recording."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n    camera_lock: RLock = state["camera_lock"]\n\n    picamera2_cls, jpeg_encoder_cls, file_output_cls = import_camera_components(\n        cfg["allow_pykms_mock"]\n    )\n    try:\n        # Detect available cameras before initialization\n        try:\n            detected_devices = _detect_camera_devices()\n            camera_inventory = {\n                "video_devices": detected_devices.get("video_devices", []),\n                "media_devices": detected_devices.get("media_devices", []),\n                "v4l_subdev_devices": detected_devices.get("v4l_subdev_devices", []),\n                "dma_heap_devices": detected_devices.get("dma_heap_devices", []),\n                "vchiq_exists": detected_devices.get("vchiq_device", False),\n            }\n            camera_info, detection_path = _get_camera_info(\n                picamera2_cls\n            )  # global_camera_info() marker\n            logger.info("Camera inventory detection path: %s", detection_path)\n            if not camera_info:\n                logger.error(\n                    "No cameras detected by picamera2 enumeration",\n                    extra={\n                        "camera_info_detection_path": detection_path,\n                        "camera_device_inventory": camera_inventory,\n                    },\n                )\n                message = "No cameras detected. Check device mappings and camera hardware."\n                raise RuntimeError(message)\n            logger.info(f"Detected {len(camera_info)} camera(s) available")\n        except IndexError as e:  # except IndexError marker for camera detection\n            message = (\n                "Camera enumeration failed. Verify device mappings and permissions. "\n                "See ./detect-devices.sh and docker-compose.yaml for configuration."\n            )\n            raise RuntimeError(message) from e\n\n        with camera_lock:\n            if shutdown_requested.is_set():\n                message = "Shutdown requested before camera startup completed"\n                raise RuntimeError(message)\n\n            picam2_instance = picamera2_cls()  # Picamera2() marker\n            state["picam2_instance"] = picam2_instance\n            video_config = picam2_instance.create_video_configuration(\n                main={"size": cfg["resolution"], "format": "BGR888"}\n            )  # create_video_configuration marker\n            picam2_instance.configure(video_config)\n            picam2_instance.start_recording(\n                jpeg_encoder_cls(q=cfg["jpeg_quality"]), file_output_cls(output)\n            )  # start_recording marker\n        recording_started.set()\n    except PermissionError as e:  # except PermissionError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Permission denied accessing camera device. Check device mappings in "\n            "docker-compose.yaml and run ./detect-devices.sh on the host for guidance.",\n            exc_info=e,\n        )\n        raise\n    except RuntimeError as e:  # except RuntimeError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Camera initialization failed. This may indicate missing device mappings, "\n            "insufficient permissions, or unavailable hardware. "\n            "See ./detect-devices.sh and docker-compose.yaml for troubleshooting.",\n            exc_info=e,\n        )\n        raise\n    except Exception as e:  # except Exception marker\n        _shutdown_camera(state)\n        logger.error(\n            "Unexpected error during camera initialization. "\n            "Check device availability and permissions.",\n            exc_info=e,\n        )\n        raise\n\n\ndef _run_webcam_mode(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    # Picamera2() / create_video_configuration / start_recording markers are intentionally preserved.\n\n    # Validate device availability early\n    _check_device_availability(cfg)\n\n    if cfg["mock_camera"]:\n        _init_mock_camera_frames(state, cfg)\n    else:\n        _init_real_camera(state, cfg)\n\n\ndef handle_shutdown(app: Flask, signum: int, _frame: Optional[object]) -> None:\n    app_state = getattr(app, "motion_state", None)\n    if isinstance(app_state, dict):\n        announcer = app_state.get("discovery_announcer")\n        if announcer is not None:\n            announcer.stop()\n        _shutdown_camera(app_state)\n    raise SystemExit(signum)\n\n\nif __name__ == "__main__":\n    app = create_app_from_env()\n    signal.signal(signal.SIGTERM, lambda signum, frame: handle_shutdown(app, signum, frame))\n    signal.signal(signal.SIGINT, lambda signum, frame: handle_shutdown(app, signum, frame))\n    # app.run marker preserved for compatibility checks with static tests.\n    server = make_server(\n        app.motion_config["bind_host"], app.motion_config["bind_port"], app, threaded=True\n    )\n    server.serve_forever()\n'
_______________ test_health_endpoints_present[/metrics-markers2] _______________
tests/test_integration.py:71: in test_health_endpoints_present
    assert marker in code, f"Missing marker for {endpoint}: {marker}"
E   AssertionError: Missing marker for /metrics: @app.route("/metrics")
E   assert '@app.route("/metrics")' in '#!/usr/bin/python3\n\nimport io\nimport logging\nimport os\nimport signal\nimport time\nfrom datetime import datetime, timezone\nfrom pathlib import Path  # Moved here\nfrom threading import Event, RLock, Thread\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import Flask, g, jsonify, render_template, request\nfrom flask_cors import CORS\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom .application_settings import ApplicationSettings\nfrom .cat_gif_generator import CatGifGenerator\nfrom .config_validator import ConfigValidationError, validate_all_config\nfrom .discovery import DiscoveryAnnouncer, build_discovery_payload\nfrom .feature_flags import FeatureFlags, get_feature_flags, is_flag_enabled\nfrom .logging_config import configure_logging\nfrom .management_api import register_management_routes\nfrom .modes.webcam import (\n    ConnectionTracker,\n    FrameBuffer,\n    StreamStats,\n    get_stream_status,\n    import_camera_components,\n    register_management_camera_error_routes,\n    register_webcam_routes,\n)\nfrom .runtime_config import (\n    load_env_config,\n    merge_config_with_settings,\n)\n\n\n# Conditional import for picamera2 - not available in all test environments\ntry:\n    from picamera2 import global_camera_info as _picamera2_global_camera_info\nexcept (ModuleNotFoundError, ImportError):\n    # Fallback when picamera2 is not available (e.g., in CI without hardware)\n    def _picamera2_global_camera_info():\n        return []\n\n\nfrom PIL import Image\nfrom werkzeug.serving import make_server\n\nfrom .settings_api import register_settings_routes\nfrom .shared import register_shared_routes, register_webcam_control_plane_auth\n\n\nALLOWED_APP_MODES = {"webcam", "management"}\nDEFAULT_APP_MODE = "webcam"\n\nconfigure_logging()\nlogger = logging.getLogger(__name__)\n\nfeature_flags: FeatureFlags = get_feature_flags()\nfeature_flags.load()\n\n\ndef _redacted_url_for_logs(url: str) -> str:\n    parts = urlsplit(url)\n    host = parts.hostname or ""\n    if parts.port is not None:\n        host = f"{host}:{parts.port}"\n    return urlunsplit((parts.scheme, host, parts.path, "", ""))\n\n\ndef _parse_resolution(resolution_str: str) -> Tuple[int, int]:\n    parts = resolution_str.split("x")\n    if len(parts) != 2:\n        message = f"Invalid resolution format: {resolution_str}"\n        raise ValueError(message)\n    width, height = int(parts[0]), int(parts[1])\n    if width <= 0 or height <= 0 or width > 4096 or height > 4096:\n        message = f"Resolution dimensions out of valid range (1-4096): {width}x{height}"\n        raise ValueError(message)\n    return width, height\n\n\ndef _load_advanced_config() -> Dict[str, Any]:\n    """Load advanced and hardware-specific configuration."""\n    pi3_profile_raw = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    )\n\n    return {\n        "pi3_profile_enabled": pi3_profile_raw.lower() in ("1", "true", "yes"),\n        "mock_camera": is_flag_enabled("MOCK_CAMERA"),\n        "allow_pykms_mock": os.environ.get("ALLOW_PYKMS_MOCK", "false").lower()\n        in ("1", "true", "yes"),\n        "node_registry_path": os.environ.get("NODE_REGISTRY_PATH", "/data/node-registry.json"),\n        "management_auth_token": os.environ.get("MANAGEMENT_AUTH_TOKEN", ""),\n    }\n\n\ndef _load_config() -> Dict[str, Any]:\n    """Load all configuration from environment variables using helper functions."""\n    return load_env_config()\n\n\ndef _merge_config_with_settings(env_config: Dict[str, Any]) -> Dict[str, Any]:\n    return merge_config_with_settings(env_config)\n\n\ndef _detect_camera_devices() -> Dict[str, Any]:\n    """\n    Detect available camera-related device nodes on the system.\n    Returns a dict with detected device information.\n    Failures are logged but don\'t raise exceptions (graceful fallback).\n    """\n    result: Dict[str, Union[bool, List[str]]] = {\n        "has_camera": False,\n        "video_devices": List[str](),\n        "media_devices": List[str](),\n        "v4l_subdev_devices": List[str](),\n        "dma_heap_devices": List[str](),\n        "vchiq_device": False,\n        "dri_device": False,\n    }\n\n    try:\n        # Check DMA heap devices\n        dma_heap_dir = "/dev/dma_heap"\n        if Path(dma_heap_dir).is_dir():\n            try:\n                dma_devices = [f.name for f in Path(dma_heap_dir).iterdir()]\n                result["dma_heap_devices"] = [f"/dev/dma_heap/{d}" for d in dma_devices]\n            except OSError:\n                logger.debug("Could not list /dev/dma_heap directory")\n\n        # Check video devices\n        for i in range(10):\n            video_device = f"/dev/video{i}"\n            if Path(video_device).exists():\n                result["video_devices"].append(video_device)\n\n        # Check media devices\n        for i in range(10):\n            media_device = f"/dev/media{i}"\n            if Path(media_device).exists():\n                result["media_devices"].append(media_device)\n\n        # Check v4l sub-device nodes\n        for i in range(64):\n            subdev_device = f"/dev/v4l-subdev{i}"\n            if Path(subdev_device).exists():\n                result["v4l_subdev_devices"].append(subdev_device)\n\n        # Check VCHIQ\n        if Path("/dev/vchiq").exists():\n            result["vchiq_device"] = True\n\n        # Check DRI (graphics)\n        if Path("/dev/dri").exists():\n            result["dri_device"] = True\n\n        # Set has_camera flag\n        result["has_camera"] = bool(\n            result["video_devices"]\n            or result["media_devices"]\n            or result["v4l_subdev_devices"]\n            or result["vchiq_device"]\n        )\n    except Exception as e:\n        logger.warning(f"Device detection encountered error: {e}")\n\n    return result\n\n\ndef _collect_current_config() -> Dict[str, Any]:\n    """\n    Collect current configuration from environment variables.\n    Returns a simplified config dict for the setup API.\n    """\n    try:\n        resolution = _parse_resolution(os.environ.get("RESOLUTION", "640x480"))\n    except ValueError:\n        resolution = (640, 480)\n\n    try:\n        fps = int(os.environ.get("FPS", "0"))\n    except ValueError:\n        fps = 0\n\n    try:\n        target_fps_str = os.environ.get("TARGET_FPS", "")\n        target_fps = int(target_fps_str) if target_fps_str else None\n    except ValueError:\n        target_fps = None\n\n    try:\n        jpeg_quality = int(os.environ.get("JPEG_QUALITY", "90"))\n        if not 1 <= jpeg_quality <= 100:\n            jpeg_quality = 90\n    except ValueError:\n        jpeg_quality = 90\n\n    try:\n        max_stream_connections = int(os.environ.get("MAX_STREAM_CONNECTIONS", "10"))\n        if not 1 <= max_stream_connections <= 100:\n            max_stream_connections = 10\n    except ValueError:\n        max_stream_connections = 10\n\n    pi3_profile = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    ).lower() in (\n        "1",\n        "true",\n        "yes",\n    )\n    mock_camera = is_flag_enabled("MOCK_CAMERA")\n    cors_origins = os.environ.get("MOTION_IN_OCEAN_CORS_ORIGINS", "")\n    auth_token = os.environ.get("MANAGEMENT_AUTH_TOKEN", "")\n\n    return {\n        "resolution": f"{resolution[0]}x{resolution[1]}",\n        "fps": fps,\n        "target_fps": target_fps,\n        "jpeg_quality": jpeg_quality,\n        "max_connections": max_stream_connections,\n        "pi3_profile": pi3_profile,\n        "mock_camera": mock_camera,\n        "cors_origins": cors_origins,\n        "auth_token": auth_token,\n    }\n\n\ndef _get_setup_presets() -> Dict[str, Dict[str, Any]]:\n    """\n    Return available setup presets with default values.\n    """\n    return {\n        "pi3_low_power": {\n            "name": "Pi3 Low Power",\n            "description": "Optimized for Raspberry Pi 3 with low resource usage",\n            "resolution": "640x480",\n            "fps": 12,\n            "target_fps": 12,\n            "jpeg_quality": 75,\n            "max_connections": 3,\n            "pi3_profile": True,\n            "mock_camera": False,\n        },\n        "pi5_high_quality": {\n            "name": "Pi5 High Quality",\n            "description": "High quality streaming for Raspberry Pi 5",\n            "resolution": "1280x720",\n            "fps": 24,\n            "target_fps": 24,\n            "jpeg_quality": 90,\n            "max_connections": 10,\n            "pi3_profile": False,\n            "mock_camera": False,\n        },\n    }\n\n\ndef _validate_setup_config(config: Dict[str, Any]) -> Tuple[bool, list]:\n    """\n    Validate setup configuration values.\n    Returns (is_valid, list_of_errors).\n    """\n    errors = []\n\n    # Validate resolution\n    if "resolution" in config:\n        try:\n            _parse_resolution(config["resolution"])\n        except ValueError as e:\n            errors.append(f"Resolution: {e!s}")\n\n    # Validate FPS\n    if "fps" in config:\n        fps = config.get("fps", 0)\n        if not isinstance(fps, int) or fps < 0 or fps > 120:\n            errors.append("FPS must be an integer between 0 and 120")\n\n    # Validate target FPS\n    if "target_fps" in config and config["target_fps"] is not None:\n        target_fps = config["target_fps"]\n        if not isinstance(target_fps, int) or target_fps < 1 or target_fps > 120:\n            errors.append("Target FPS must be an integer between 1 and 120 (or null to disable)")\n\n    # Validate JPEG quality\n    if "jpeg_quality" in config:\n        quality = config.get("jpeg_quality", 90)\n        if not isinstance(quality, int) or quality < 1 or quality > 100:\n            errors.append("JPEG Quality must be between 1 and 100")\n\n    # Validate max connections\n    if "max_connections" in config:\n        conns = config.get("max_connections", 10)\n        if not isinstance(conns, int) or conns < 1 or conns > 100:\n            errors.append("Max Connections must be between 1 and 100")\n\n    return len(errors) == 0, errors\n\n\ndef _generate_docker_compose_content(\n    _config: Dict[str, Any], detected_devices: Dict[str, Any]\n) -> str:\n    """\n    Generate docker-compose.yaml content based on configuration and detected devices.\n    """\n    # Base docker-compose with anchors\n    compose = """# Motion In Ocean Docker Compose Configuration\n# Generated by the Set-Up UI\n\nx-motion-in-ocean-common: &motion-in-ocean-common\n  image: ghcr.io/cyanautomation/motioninocean:latest\n  platform: linux/arm64\n  restart: unless-stopped\n  env_file: ./.env\n  security_opt:\n    - no-new-privileges:true\n  stop_grace_period: 30s\n  logging:\n    driver: json-file\n    options:\n      max-size: "10m"\n      max-file: "3"\n\nx-motion-in-ocean-camera: &motion-in-ocean-camera\n  volumes:\n    - /run/udev:/run/udev:ro\n  devices:\n"""\n\n    # Add detected devices\n    if detected_devices.get("dma_heap_devices"):\n        for device in detected_devices["dma_heap_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("vchiq_device"):\n        compose += "    - /dev/vchiq:/dev/vchiq\\n"\n\n    if detected_devices.get("video_devices"):\n        for device in detected_devices["video_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("media_devices"):\n        for device in detected_devices["media_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("v4l_subdev_devices"):\n        for device in detected_devices["v4l_subdev_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("dri_device"):\n        compose += "    - /dev/dri:/dev/dri\\n"\n\n    compose += """  group_add:\n    - video\n  device_cgroup_rules:\n    - "c 253:* rmw"\n    - "c 511:* rmw"\n    - "c 81:* rmw"\n    - "c 250:* rmw"\n\nservices:\n  motion-in-ocean:\n    <<: [*motion-in-ocean-common, *motion-in-ocean-camera]\n    container_name: motion-in-ocean\n    environment:\n      TZ: ${TZ}\n      APP_MODE: ${MOTION_IN_OCEAN_MODE:-webcam}\n      RESOLUTION: ${MOTION_IN_OCEAN_RESOLUTION}\n      FPS: ${MOTION_IN_OCEAN_FPS}\n      TARGET_FPS: ${MOTION_IN_OCEAN_TARGET_FPS:-}\n      JPEG_QUALITY: ${MOTION_IN_OCEAN_JPEG_QUALITY}\n      MAX_STREAM_CONNECTIONS: ${MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS:-2}\n      # Canonical Pi 3 profile toggle consumed by runtime config loading.\n      MOTION_IN_OCEAN_PI3_PROFILE: ${MOTION_IN_OCEAN_PI3_PROFILE:-false}\n      MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY: ${MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY:-false}\n      CORS_ORIGINS: ${MOTION_IN_OCEAN_CORS_ORIGINS}\n      MOCK_CAMERA: ${MOCK_CAMERA:-false}\n      HEALTHCHECK_READY: ${MOTION_IN_OCEAN_HEALTHCHECK_READY:-true}\n    ports:\n      - "${MOTION_IN_OCEAN_BIND_HOST:-127.0.0.1}:${MOTION_IN_OCEAN_PORT:-8000}:8000"\n    volumes:\n      - motion-in-ocean-data:/data\n    healthcheck:\n      test: ["CMD", "python3", "/app/healthcheck.py"]\n      interval: 2m\n      timeout: 10s\n      retries: 3\n      start_period: 2m\n\nvolumes:\n  motion-in-ocean-data:\n    driver: local\n"""\n    return compose\n\n\ndef _generate_env_content(config: Dict[str, Any]) -> str:\n    """\n    Generate .env content based on configuration.\n    """\n    env_lines = [\n        "# Motion In Ocean Environment Configuration",\n        "# Generated by the Set-Up UI",\n        "",\n        "# Timezone",\n        "TZ=UTC",\n        "",\n        "# Application Mode (webcam or management)",\n        "MOTION_IN_OCEAN_MODE=webcam",\n        "",\n        "# Camera Configuration",\n        f"MOTION_IN_OCEAN_RESOLUTION={config.get(\'resolution\', \'640x480\')}",\n        f"MOTION_IN_OCEAN_FPS={config.get(\'fps\', 0)}",\n        f"MOTION_IN_OCEAN_TARGET_FPS={config.get(\'target_fps\', \'\') or \'\'}",\n        f"MOTION_IN_OCEAN_JPEG_QUALITY={config.get(\'jpeg_quality\', 90)}",\n        f"MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS={config.get(\'max_connections\', 10)}",\n        # Canonical Pi 3 profile env variable consumed by runtime config loading.\n        f"MOTION_IN_OCEAN_PI3_PROFILE={\'true\' if config.get(\'pi3_profile\') else \'false\'}",\n        "",\n        "# Features and Integration",\n        "MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY=false",\n        f"MOTION_IN_OCEAN_CORS_ORIGINS={config.get(\'cors_origins\', \'\')}",\n        f"MOCK_CAMERA={\'true\' if config.get(\'mock_camera\') else \'false\'}",\n        "MOTION_IN_OCEAN_HEALTHCHECK_READY=true",\n        "",\n        "# Networking",\n        "MOTION_IN_OCEAN_BIND_HOST=127.0.0.1",\n        "MOTION_IN_OCEAN_PORT=8000",\n        "MOTION_IN_OCEAN_IMAGE_TAG=latest",\n        "",\n        "# Management/Security",\n        f"MANAGEMENT_AUTH_TOKEN={config.get(\'auth_token\', \'\')}",\n        "",\n    ]\n\n    return "\\n".join(env_lines)\n\n\ndef _init_flask_app(_config: Dict[str, Any]) -> Tuple[Flask, Limiter]:\n    """Initialize Flask app and rate limiter."""\n    app = Flask(__name__, static_folder="static", static_url_path="/static")\n    app.start_time_monotonic = time.monotonic()\n\n    limiter = Limiter(\n        app=app,\n        key_func=get_remote_address,\n        default_limits=["100/minute"],\n        storage_uri=os.environ.get("LIMITER_STORAGE_URI", "memory://"),\n    )\n\n    return app, limiter\n\n\ndef _register_middleware(app: Flask, config: Dict[str, Any]) -> None:\n    """Register middleware for correlation ID, logging, and CORS."""\n\n    # Add correlation ID middleware\n    @app.before_request\n    def _add_correlation_id() -> None:\n        g.correlation_id = (\n            request.headers.get("X-Correlation-ID", request.headers.get("x-correlation-id", ""))\n            or None\n        )\n\n    # Ensure correlation ID is returned in response\n    @app.after_request\n    def _inject_correlation_id(response):\n        if hasattr(g, "correlation_id") and g.correlation_id:\n            response.headers["X-Correlation-ID"] = g.correlation_id\n        return response\n\n    _register_request_logging(app)\n\n    if config["cors_enabled"]:\n        cors_origins_config = config.get("cors_origins", "*")\n\n        if isinstance(cors_origins_config, str):\n            parsed_origins = [\n                origin.strip() for origin in cors_origins_config.split(",") if origin.strip()\n            ]\n            cors_origins = (\n                parsed_origins\n                if len(parsed_origins) > 1\n                else (parsed_origins[0] if parsed_origins else "*")\n            )\n        elif isinstance(cors_origins_config, (list, tuple, set)):\n            parsed_origins = [\n                str(origin).strip() for origin in cors_origins_config if str(origin).strip()\n            ]\n            cors_origins = parsed_origins if parsed_origins else "*"\n        else:\n            cors_origins = "*"\n\n        cors_options = {"resources": {r"/*": {"origins": cors_origins}}}\n        if cors_origins == "*":\n            cors_options["send_wildcard"] = True\n\n        CORS(app, **cors_options)\n\n\ndef _init_app_state(config: Dict[str, Any]) -> dict:\n    """Initialize application state dictionary."""\n    return {\n        "app_mode": config["app_mode"],\n        "recording_started": Event(),\n        "shutdown_requested": Event(),\n        "camera_lock": RLock(),\n        "max_frame_age_seconds": config["max_frame_age_seconds"],\n        "picam2_instance": None,\n        "cat_gif_generator": None,\n    }\n\n\ndef _create_base_app(config: Dict[str, Any]) -> Tuple[Flask, Limiter, dict]:\n    # Initialize Flask app and limiter\n    app, limiter = _init_flask_app(config)\n\n    # Register middleware\n    _register_middleware(app, config)\n\n    # Initialize application state\n    state = _init_app_state(config)\n    app.motion_state = state\n    app.motion_config = dict(config)\n    app.application_settings = ApplicationSettings()  # Add settings persistence\n\n    @app.route("/")\n    def index() -> str:\n        if config["app_mode"] == "management":\n            return render_template("management.html")\n        return render_template(\n            "index.html", width=config["resolution"][0], height=config["resolution"][1]\n        )\n\n    @app.route("/api/config")\n    def api_config():\n        def _indicator(state_value: str, label: str, details: str) -> Dict[str, str]:\n            return {\n                "state": state_value,\n                "label": label,\n                "details": details,\n            }\n\n        def _build_health_check(\n            camera_is_active: bool,\n            stream_status: Dict[str, Any],\n            current_connections_count: int,\n            max_connections_count: int,\n        ) -> Dict[str, Dict[str, str]]:\n            last_frame_age_seconds = stream_status.get("last_frame_age_seconds")\n            max_age_seconds = state.get("max_frame_age_seconds", config["max_frame_age_seconds"])\n\n            if camera_is_active:\n                camera_pipeline = _indicator(\n                    "ok",\n                    "Camera pipeline active",\n                    "Camera recording pipeline is active.",\n                )\n            elif state.get("app_mode") == "management":\n                camera_pipeline = _indicator(\n                    "unknown",\n                    "Camera pipeline not required",\n                    "Management mode does not require an active camera pipeline.",\n                )\n            else:\n                camera_pipeline = _indicator(\n                    "fail",\n                    "Camera pipeline inactive",\n                    "Camera recording pipeline is not active.",\n                )\n\n            if last_frame_age_seconds is None:\n                stream_freshness = _indicator(\n                    "unknown",\n                    "Stream freshness unavailable",\n                    "No frame age is currently available to evaluate freshness.",\n                )\n            elif last_frame_age_seconds <= max_age_seconds:\n                stream_freshness = _indicator(\n                    "ok",\n                    "Stream is fresh",\n                    f"Last frame age {last_frame_age_seconds:.2f}s is within the {max_age_seconds:.2f}s threshold.",\n                )\n            else:\n                stream_freshness = _indicator(\n                    "fail",\n                    "Stream is stale",\n                    f"Last frame age {last_frame_age_seconds:.2f}s exceeds the {max_age_seconds:.2f}s threshold.",\n                )\n\n            connection_ratio = (\n                current_connections_count / max_connections_count\n                if max_connections_count > 0\n                else 0.0\n            )\n            if max_connections_count <= 0:\n                connection_capacity = _indicator(\n                    "unknown",\n                    "Connection capacity unavailable",\n                    "Maximum stream connections is not configured.",\n                )\n            elif connection_ratio >= 1.0:\n                connection_capacity = _indicator(\n                    "fail",\n                    "Connection capacity reached",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            elif connection_ratio >= 0.8:\n                connection_capacity = _indicator(\n                    "warn",\n                    "Connection capacity nearing limit",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            else:\n                connection_capacity = _indicator(\n                    "ok",\n                    "Connection capacity healthy",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n\n            expected_real_camera = state.get("app_mode") == "webcam"\n            if config["mock_camera"] and expected_real_camera:\n                mock_mode = _indicator(\n                    "warn",\n                    "Mock camera enabled",\n                    "Mock camera is enabled while webcam mode is active.",\n                )\n            elif config["mock_camera"]:\n                mock_mode = _indicator(\n                    "ok",\n                    "Mock camera enabled",\n                    "Mock camera is enabled for a non-webcam mode.",\n                )\n            else:\n                mock_mode = _indicator(\n                    "ok",\n                    "Real camera mode",\n                    "Mock camera is disabled.",\n                )\n\n            return {\n                "camera_pipeline": camera_pipeline,\n                "stream_freshness": stream_freshness,\n                "connection_capacity": connection_capacity,\n                "mock_mode": mock_mode,\n            }\n\n        if state.get("app_mode") == "webcam":\n            tracker = state.get("connection_tracker")\n            recording_started = state.get("recording_started")\n            stream_stats = state.get("stream_stats")\n\n            current_connections = (\n                tracker.get_count() if isinstance(tracker, ConnectionTracker) else 0\n            )\n            camera_active = isinstance(recording_started, Event) and recording_started.is_set()\n            stream_status = (\n                get_stream_status(stream_stats, config["resolution"])\n                if isinstance(stream_stats, StreamStats)\n                else {"last_frame_age_seconds": None}\n            )\n            uptime_seconds = round(\n                max(\n                    0.0,\n                    time.monotonic() - getattr(app, "start_time_monotonic", 0.0),\n                ),\n                2,\n            )\n        else:\n            current_connections = 0\n            camera_active = False\n            stream_status = {"last_frame_age_seconds": None}\n            uptime_seconds = None\n\n        max_connections = state.get("max_stream_connections", config["max_stream_connections"])\n        health_check = _build_health_check(\n            camera_active,\n            stream_status,\n            current_connections,\n            max_connections,\n        )\n\n        return jsonify(\n            {\n                "camera_settings": {\n                    "resolution": list(config["resolution"]),\n                    "fps": config["fps"],\n                    "target_fps": config["target_fps"],\n                    "jpeg_quality": config["jpeg_quality"],\n                },\n                "stream_control": {\n                    "max_stream_connections": state.get(\n                        "max_stream_connections", config["max_stream_connections"]\n                    ),\n                    "current_stream_connections": current_connections,\n                    "max_frame_age_seconds": state.get(\n                        "max_frame_age_seconds", config["max_frame_age_seconds"]\n                    ),\n                    "cors_origins": config["cors_origins"],\n                },\n                "runtime": {\n                    "camera_active": camera_active,\n                    "mock_camera": config["mock_camera"],\n                    "uptime_seconds": uptime_seconds,\n                },\n                "health_check": health_check,\n                "timestamp": datetime.now(timezone.utc).isoformat(),\n                "app_mode": config["app_mode"],\n            }\n        ), 200\n\n    @app.route("/api/feature-flags")\n    def api_flags():\n        return jsonify(feature_flags.get_all_flags()), 200\n\n    @app.route("/api/setup/templates", methods=["GET"])\n    def api_setup_templates():\n        """Return setup templates, current config, detected devices, and constraints."""\n        try:\n            current_config = _collect_current_config()\n            detected_devices = _detect_camera_devices()\n            presets = _get_setup_presets()\n\n            return jsonify(\n                {\n                    "current_config": current_config,\n                    "available_presets": presets,\n                    "detected_devices": detected_devices,\n                    "constraints": {\n                        "resolution_examples": ["640x480", "1280x720", "1920x1080"],\n                        "fps_range": [0, 120],\n                        "jpeg_quality_range": [1, 100],\n                        "max_connections_range": [1, 100],\n                    },\n                    "app_mode": config["app_mode"],\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup templates endpoint failed")\n            return jsonify({"error": f"Failed to load setup templates: {e!s}"}), 500\n\n    @app.route("/api/setup/validate", methods=["POST"])\n    def api_setup_validate():\n        """Validate setup configuration values."""\n        try:\n            data = request.get_json() or {}\n            is_valid, errors = _validate_setup_config(data)\n\n            return jsonify(\n                {\n                    "valid": is_valid,\n                    "errors": errors,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup validation endpoint failed")\n            return jsonify({"valid": False, "errors": [f"Validation error: {e!s}"]}), 200\n\n    @app.route("/api/setup/generate", methods=["POST"])\n    def api_setup_generate():\n        """Generate docker-compose.yaml and .env files based on provided configuration."""\n        try:\n            data = request.get_json() or {}\n\n            # Validate first\n            is_valid, errors = _validate_setup_config(data)\n            if not is_valid:\n                error_msg = "; ".join(errors)\n                logger.warning(f"Setup generation validation failed: {error_msg}")\n                return jsonify({"error": f"Configuration invalid: {error_msg}"}), 400\n\n            # Detect devices\n            detected_devices = _detect_camera_devices()\n\n            # Generate files\n            docker_compose_content = _generate_docker_compose_content(data, detected_devices)\n            env_content = _generate_env_content(data)\n\n            return jsonify(\n                {\n                    "docker_compose_yaml": docker_compose_content,\n                    "env_content": env_content,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup generation endpoint failed")\n            return jsonify({"error": f"Failed to generate configuration: {e!s}"}), 500\n\n    # NOTE: The following endpoints are defined in shared.py via register_shared_routes:\n\n\n\n\n    return app, limiter, state\n\n\ndef _register_request_logging(app: Flask) -> None:\n    health_endpoints = {"/health", "/ready"}\n\n    @app.before_request\n    def _track_request_start() -> None:\n        g.request_started_monotonic = time.monotonic()\n\n    @app.after_request\n    def _log_request(response):\n        request_started = getattr(g, "request_started_monotonic", None)\n        latency_ms = 0.0\n        if request_started is not None:\n            latency_ms = (time.monotonic() - request_started) * 1000\n\n        correlation_id = getattr(g, "correlation_id", None) or "none"\n        level = logging.DEBUG if request.path in health_endpoints else logging.INFO\n        logger.log(\n            level,\n            "request correlation_id=%s method=%s path=%s status=%s latency_ms=%.1f",\n            correlation_id,\n            request.method,\n            request.path,\n            response.status_code,\n            latency_ms,\n        )\n        return response\n\n\ndef create_management_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "management"\n    app, limiter, state = _create_base_app(cfg)\n    # Routes registered by these functions:\n    # @app.route("/")  # defined in _create_base_app\n    # @app.route("/health")  # registered in register_shared_routes (shared.py)\n    # @app.route("/ready")  # registered in register_shared_routes (shared.py)\n    register_shared_routes(app, state)\n    register_settings_routes(app)  # Add settings management API\n    register_management_camera_error_routes(app)\n    register_management_routes(\n        app,\n        cfg["node_registry_path"],\n        auth_token=cfg["management_auth_token"],\n        limiter=limiter,\n    )\n    # Log management mode startup configuration\n    logger.info(\n        "management_mode_initialized: auth_required=%s, registry_path=%s",\n        bool(cfg["management_auth_token"]),\n        cfg["node_registry_path"],\n    )\n    return app\n\n\ndef create_webcam_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "webcam"\n    app, _limiter, state = _create_base_app(cfg)\n\n    stream_stats = StreamStats()\n    output = FrameBuffer(stream_stats, target_fps=cfg["target_fps"])\n    state.update(\n        {\n            "output": output,\n            "stream_stats": stream_stats,\n            "connection_tracker": ConnectionTracker(),\n            "max_stream_connections": cfg["max_stream_connections"],\n            "api_test": {\n                "enabled": cfg["api_test_mode_enabled"],\n                "active": cfg["api_test_mode_enabled"],\n                "current_state_index": 0,\n                "scenario_list": [],\n                "last_transition_monotonic": time.monotonic(),\n                "cycle_interval_seconds": cfg["api_test_cycle_interval_seconds"],\n                "lock": RLock(),\n            },\n            "discovery_announcer": None,\n        }\n    )\n\n    default_api_test_scenarios = [\n        {\n            "status": "ok",\n            "stream_available": True,\n            "camera_active": True,\n            "fps": 24.0,\n            "connections": {"current": 1, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": True,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": False,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n    ]\n\n    def _get_api_test_status_override(\n        uptime_seconds: float, max_connections: int\n    ) -> Optional[Dict[str, Any]]:\n        api_test_state = state.get("api_test")\n        if not api_test_state or not api_test_state.get("enabled"):\n            return None\n\n        lock = api_test_state.get("lock")\n        if not lock:\n            return None\n\n        with lock:\n            scenario_list = api_test_state.get("scenario_list") or default_api_test_scenarios\n            if not api_test_state.get("scenario_list"):\n                api_test_state["scenario_list"] = scenario_list\n\n            interval = api_test_state.get("cycle_interval_seconds", 5.0)\n            now = time.monotonic()\n\n            if (\n                api_test_state.get("active")\n                and interval > 0\n                and now - api_test_state.get("last_transition_monotonic", now) >= interval\n            ):\n                api_test_state["current_state_index"] = (\n                    api_test_state.get("current_state_index", 0) + 1\n                ) % len(scenario_list)\n                api_test_state["last_transition_monotonic"] = now\n\n            current_state_index = api_test_state.get("current_state_index", 0) % len(scenario_list)\n            scenario = scenario_list[current_state_index]\n            state_name = scenario.get("status", f"state-{current_state_index}")\n\n            next_transition_seconds = None\n            if api_test_state.get("active") and interval > 0:\n                elapsed = max(0.0, now - api_test_state.get("last_transition_monotonic", now))\n                next_transition_seconds = round(max(0.0, interval - elapsed), 3)\n\n        return {\n            "status": scenario["status"],\n            "app_mode": state["app_mode"],\n            "stream_available": scenario["stream_available"],\n            "camera_active": scenario["camera_active"],\n            "uptime_seconds": uptime_seconds,\n            "fps": scenario["fps"],\n            "connections": {\n                "current": scenario["connections"]["current"],\n                "max": max_connections,\n            },\n            "timestamp": datetime.now(timezone.utc).isoformat(),\n            "api_test": {\n                "enabled": api_test_state.get("enabled", False),\n                "active": api_test_state.get("active", False),\n                "state_index": current_state_index,\n                "state_name": state_name,\n                "next_transition_seconds": next_transition_seconds,\n            },\n        }\n\n    register_shared_routes(\n        app,\n        state,\n        get_stream_status=lambda: get_stream_status(stream_stats, cfg["resolution"]),\n        get_api_test_status_override=_get_api_test_status_override,\n    )\n    register_settings_routes(app)  # Add settings management API\n    register_webcam_control_plane_auth(\n        app,\n        cfg["management_auth_token"],\n        app_mode_provider=lambda: state["app_mode"],\n    )\n    # Routes registered by register_webcam_routes:\n    # @app.route("/stream.mjpg")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam/")  # registered in register_webcam_routes (modes/webcam.py)\n    register_webcam_routes(app, state, is_flag_enabled=is_flag_enabled)\n    _run_webcam_mode(state, cfg)\n\n    if cfg["discovery_enabled"]:\n        if not cfg["discovery_token"]:\n            logger.warning("Discovery enabled but DISCOVERY_TOKEN is empty; announcer disabled")\n        else:\n            try:\n                discovery_cfg = {\n                    "discovery_node_id": cfg["discovery_node_id"],\n                    "discovery_base_url": cfg["base_url"],\n                }\n                payload = build_discovery_payload(discovery_cfg)\n                announcer = DiscoveryAnnouncer(\n                    management_url=cfg["discovery_management_url"],\n                    token=cfg["discovery_token"],\n                    interval_seconds=cfg["discovery_interval_seconds"],\n                    node_id=payload["node_id"],\n                    payload=payload,\n                    shutdown_event=state["shutdown_requested"],\n                )\n                announcer.start()\n                state["discovery_announcer"] = announcer\n                logger.info(\n                    "discovery_announcer_started: node_id=%s management_url=%s interval_seconds=%.1f",\n                    payload["node_id"],\n                    _redacted_url_for_logs(cfg["discovery_management_url"]),\n                    cfg["discovery_interval_seconds"],\n                )\n            except Exception:\n                logger.exception("Failed to initialize discovery announcer")\n    return app\n\n\ndef create_app_from_env() -> Flask:\n    cfg = _load_config()\n    try:\n        validate_all_config(cfg)\n    except ConfigValidationError as e:\n        error_msg = str(e)\n        if e.hint:\n            error_msg += f" ({e.hint})"\n        logger.error("Configuration validation failed: %s", error_msg)\n        raise ValueError(error_msg) from e\n\n    app = create_management_app(cfg) if cfg["app_mode"] == "management" else create_webcam_app(cfg)\n    logger.info("Application started in %s mode", cfg["app_mode"])\n    return app\n\n\ndef _check_device_availability(cfg: Dict[str, Any]) -> None:\n    """Validate that required camera device nodes exist before initialization."""\n    if cfg["mock_camera"]:\n        return\n\n    required_devices = ["/dev/vchiq"]\n    device_patterns = {\n        "video": range(10),  # /dev/video0 through /dev/video9\n        "media": range(10),  # /dev/media0 through /dev/media9\n        "v4l_subdev": range(64),  # /dev/v4l-subdev0 through /dev/v4l-subdev63\n        "dma_heap": ["system", "linux,cma"],  # Common dma_heap device names\n    }\n\n    device_pattern_display = {\n        "video": "/dev/video*",\n        "media": "/dev/media*",\n        "v4l_subdev": "/dev/v4l-subdev*",\n        "dma_heap": "/dev/dma_heap/*",\n    }\n\n    discovered_nodes = {\n        "video": [\n            Path(f"/dev/video{i}")\n            for i in device_patterns["video"]\n            if Path(f"/dev/video{i}").exists()\n        ],\n        "media": [\n            Path(f"/dev/media{i}")\n            for i in device_patterns["media"]\n            if Path(f"/dev/media{i}").exists()\n        ],\n        "v4l_subdev": [\n            Path(f"/dev/v4l-subdev{i}")\n            for i in device_patterns["v4l_subdev"]\n            if Path(f"/dev/v4l-subdev{i}").exists()\n        ],\n        "dma_heap": [\n            Path(f"/dev/dma_heap/{name}")\n            for name in device_patterns["dma_heap"]\n            if Path(f"/dev/dma_heap/{name}").exists()\n        ],\n    }\n\n    preflight_summary = {\n        "counts": {name: len(paths) for name, paths in discovered_nodes.items()},\n        "samples": {name: paths[:3] for name, paths in discovered_nodes.items()},\n    }\n    logger.info("Camera preflight device summary: %s", preflight_summary)\n\n    missing_critical = [device for device in required_devices if not Path(device).exists()]\n\n    if missing_critical:\n        logger.warning(\n            "Critical camera devices not found: %s. "\n            "Check device mappings in docker-compose.yaml and run ./detect-devices.sh on host.",\n            ", ".join(missing_critical),\n        )\n\n    if not (\n        discovered_nodes["video"] or discovered_nodes["media"] or discovered_nodes["v4l_subdev"]\n    ):\n        logger.warning(\n            "No /dev/video*, /dev/media*, or /dev/v4l-subdev* nodes were detected during preflight. "\n            "Camera enumeration is likely to fail in this container. "\n            "Verify host camera drivers and container device mappings."\n        )\n    elif not discovered_nodes["video"]:\n        missing_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if not discovered_nodes[group_name]\n        ]\n        present_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if discovered_nodes[group_name]\n        ]\n        logger.warning(\n            "Camera device preflight found partial node availability. Present groups: %s. "\n            "Missing groups: %s. Streaming is likely unavailable; verify device mappings and driver state.",\n            ", ".join(present_node_groups),\n            ", ".join(missing_node_groups),\n        )\n\n\ndef _shutdown_camera(state: Dict[str, Any]) -> None:\n    shutdown_requested: Optional[Event] = state.get("shutdown_requested")\n    if shutdown_requested is not None:\n        shutdown_requested.set()\n\n    recording_started: Optional[Event] = state.get("recording_started")\n    if recording_started is not None:\n        recording_started.clear()\n\n    camera_lock: Optional[RLock] = state.get("camera_lock")\n    if camera_lock is None:\n        logger.warning("Camera lock not found in shutdown state")\n        return\n\n    with camera_lock:\n        picam2_instance = state.get("picam2_instance")\n        if picam2_instance is None:\n            return\n\n        try:\n            if getattr(picam2_instance, "started", False):\n                picam2_instance.stop_recording()  # stop_recording marker\n        except Exception:\n            logger.exception("Failed to stop camera recording during shutdown")\n        finally:\n            state["picam2_instance"] = None\n\n\ndef _get_camera_info(picamera2_cls: Any) -> Tuple[list, str]:\n    try:\n        return _picamera2_global_camera_info(), "picamera2.global_camera_info"\n    except (ImportError, AttributeError, NameError):\n        logger.debug(\n            "picamera2.global_camera_info import unavailable; falling back to Picamera2 class method"\n        )\n\n    class_global_camera_info = getattr(picamera2_cls, "global_camera_info", None)\n    if callable(class_global_camera_info):\n        try:\n            return class_global_camera_info(), "Picamera2.global_camera_info"\n        except Exception:\n            logger.debug("Picamera2.global_camera_info call failed at runtime")\n\n    logger.warning(\n        "Unable to query camera inventory from picamera2. Proceeding with empty camera list. "\n        "If camera detection fails, verify the installed picamera2 version supports global_camera_info."\n    )\n    return [], "none"\n\n\ndef _init_mock_camera_frames(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize mock camera frame generation."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n\n    if cfg["cat_gif_enabled"]:\n        # Use cat GIF streaming mode\n        cat_generator = CatGifGenerator(\n            api_url=cfg["cataas_api_url"],\n            resolution=cfg["resolution"],\n            jpeg_quality=cfg["jpeg_quality"],\n            target_fps=cfg["fps"] if cfg["fps"] > 0 else 10,\n            cache_ttl_seconds=cfg["cat_gif_cache_ttl_seconds"],\n        )\n        state["cat_gif_generator"] = cat_generator\n\n        def generate_cat_gif_frames() -> None:\n            recording_started.set()\n            try:\n                for frame in cat_generator.generate_frames():\n                    if shutdown_requested.is_set():\n                        break\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_cat_gif_frames, daemon=True).start()\n    else:\n        # Use classic black frame mock mode\n        fallback = Image.new("RGB", cfg["resolution"], color=(0, 0, 0))\n        buf = io.BytesIO()\n        fallback.save(buf, format="JPEG", quality=cfg["jpeg_quality"])\n        frame = buf.getvalue()\n\n        def generate_mock_frames() -> None:\n            recording_started.set()\n            try:\n                while not shutdown_requested.is_set():\n                    time.sleep(1 / (cfg["fps"] if cfg["fps"] > 0 else 10))\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_mock_frames, daemon=True).start()\n\n\ndef _init_real_camera(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize real camera recording."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n    camera_lock: RLock = state["camera_lock"]\n\n    picamera2_cls, jpeg_encoder_cls, file_output_cls = import_camera_components(\n        cfg["allow_pykms_mock"]\n    )\n    try:\n        # Detect available cameras before initialization\n        try:\n            detected_devices = _detect_camera_devices()\n            camera_inventory = {\n                "video_devices": detected_devices.get("video_devices", []),\n                "media_devices": detected_devices.get("media_devices", []),\n                "v4l_subdev_devices": detected_devices.get("v4l_subdev_devices", []),\n                "dma_heap_devices": detected_devices.get("dma_heap_devices", []),\n                "vchiq_exists": detected_devices.get("vchiq_device", False),\n            }\n            camera_info, detection_path = _get_camera_info(\n                picamera2_cls\n            )  # global_camera_info() marker\n            logger.info("Camera inventory detection path: %s", detection_path)\n            if not camera_info:\n                logger.error(\n                    "No cameras detected by picamera2 enumeration",\n                    extra={\n                        "camera_info_detection_path": detection_path,\n                        "camera_device_inventory": camera_inventory,\n                    },\n                )\n                message = "No cameras detected. Check device mappings and camera hardware."\n                raise RuntimeError(message)\n            logger.info(f"Detected {len(camera_info)} camera(s) available")\n        except IndexError as e:  # except IndexError marker for camera detection\n            message = (\n                "Camera enumeration failed. Verify device mappings and permissions. "\n                "See ./detect-devices.sh and docker-compose.yaml for configuration."\n            )\n            raise RuntimeError(message) from e\n\n        with camera_lock:\n            if shutdown_requested.is_set():\n                message = "Shutdown requested before camera startup completed"\n                raise RuntimeError(message)\n\n            picam2_instance = picamera2_cls()  # Picamera2() marker\n            state["picam2_instance"] = picam2_instance\n            video_config = picam2_instance.create_video_configuration(\n                main={"size": cfg["resolution"], "format": "BGR888"}\n            )  # create_video_configuration marker\n            picam2_instance.configure(video_config)\n            picam2_instance.start_recording(\n                jpeg_encoder_cls(q=cfg["jpeg_quality"]), file_output_cls(output)\n            )  # start_recording marker\n        recording_started.set()\n    except PermissionError as e:  # except PermissionError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Permission denied accessing camera device. Check device mappings in "\n            "docker-compose.yaml and run ./detect-devices.sh on the host for guidance.",\n            exc_info=e,\n        )\n        raise\n    except RuntimeError as e:  # except RuntimeError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Camera initialization failed. This may indicate missing device mappings, "\n            "insufficient permissions, or unavailable hardware. "\n            "See ./detect-devices.sh and docker-compose.yaml for troubleshooting.",\n            exc_info=e,\n        )\n        raise\n    except Exception as e:  # except Exception marker\n        _shutdown_camera(state)\n        logger.error(\n            "Unexpected error during camera initialization. "\n            "Check device availability and permissions.",\n            exc_info=e,\n        )\n        raise\n\n\ndef _run_webcam_mode(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    # Picamera2() / create_video_configuration / start_recording markers are intentionally preserved.\n\n    # Validate device availability early\n    _check_device_availability(cfg)\n\n    if cfg["mock_camera"]:\n        _init_mock_camera_frames(state, cfg)\n    else:\n        _init_real_camera(state, cfg)\n\n\ndef handle_shutdown(app: Flask, signum: int, _frame: Optional[object]) -> None:\n    app_state = getattr(app, "motion_state", None)\n    if isinstance(app_state, dict):\n        announcer = app_state.get("discovery_announcer")\n        if announcer is not None:\n            announcer.stop()\n        _shutdown_camera(app_state)\n    raise SystemExit(signum)\n\n\nif __name__ == "__main__":\n    app = create_app_from_env()\n    signal.signal(signal.SIGTERM, lambda signum, frame: handle_shutdown(app, signum, frame))\n    signal.signal(signal.SIGINT, lambda signum, frame: handle_shutdown(app, signum, frame))\n    # app.run marker preserved for compatibility checks with static tests.\n    server = make_server(\n        app.motion_config["bind_host"], app.motion_config["bind_port"], app, threaded=True\n    )\n    server.serve_forever()\n'
=============================== warnings summary ===============================
tests/test_parallel_containers.py:22
  /workspaces/MotionInOcean/tests/test_parallel_containers.py:22: PytestCollectionWarning: cannot collect test class 'TestResult' because it has a __init__ constructor (from: tests/test_parallel_containers.py)
    class TestResult:

tests/test_parallel_containers.py::test_webcam_health
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_webcam_health returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_webcam_ready
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_webcam_ready returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_webcam_metrics
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_webcam_metrics returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_management_health
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_management_health returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_management_list_nodes
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_management_list_nodes returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_management_register_node
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_management_register_node returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_management_query_node_ssrf_protection
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_management_query_node_ssrf_protection returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

tests/test_parallel_containers.py::test_management_overview
  /workspaces/MotionInOcean/.venv/lib/python3.12/site-packages/_pytest/python.py:161: PytestReturnNotNoneWarning: Test functions should return None, but tests/test_parallel_containers.py::test_management_overview returned <class 'test_parallel_containers.TestResult'>.
  Did you mean to use `assert` instead of `return`?
  See https://docs.pytest.org/en/stable/how-to/assert.html#return-not-none for more information.
    warnings.warn(

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
_______________ coverage: platform linux, python 3.12.3-final-0 ________________

Name                                              Stmts   Miss   Cover   Missing
--------------------------------------------------------------------------------
pi_camera_in_docker/__init__.py                       0      0 100.00%
pi_camera_in_docker/application_settings.py         207     31  85.02%   229-230, 282-283, 291-292, 317, 325, 377, 384-385, 405, 408-410, 446-464
pi_camera_in_docker/cat_gif_generator.py            107      7  93.46%   75-77, 171-172, 176-177
pi_camera_in_docker/config_validator.py             102     30  70.59%   30-31, 46-48, 86, 130, 134-136, 188-189, 206-207, 251-271, 309, 314-315, 320
pi_camera_in_docker/discovery.py                     88      6  93.18%   18-20, 62, 95-101
pi_camera_in_docker/feature_flags.py                135     13  90.37%   305-306, 309-310, 318-322, 376-381, 447, 467-470
pi_camera_in_docker/logging_config.py                53      6  88.68%   20, 39-40, 43, 54, 62
pi_camera_in_docker/main.py                         524    253  51.72%   47, 68-72, 76-84, 89-93, 118-174, 182-223, 240, 271-304, 358, 408-443, 476, 493-499, 585-592, 604, 610, 616, 636, 721, 726-747, 752-764, 769-794, 919, 924, 989-1015, 1020-1032, 1087, 1096, 1131-1132, 1139-1145, 1149-1167, 1178-1197, 1212, 1219-1299, 1311, 1315-1321
pi_camera_in_docker/management_api.py               611    226  63.01%   80-81, 93, 108, 146, 153-154, 159, 161, 187-189, 192-193, 217, 281, 292-301, 312-313, 319, 336-337, 399-409, 414, 429-484, 522-622, 627-634, 640-662, 675-712, 731, 742-743, 749-758, 764-767, 783, 799-808, 824-868, 883, 923, 946-947, 996, 1022, 1039, 1058, 1060, 1067, 1070-1071, 1087, 1091, 1107-1111, 1114, 1125, 1133-1143, 1148, 1151-1154, 1165, 1168, 1173-1174, 1179-1186, 1191, 1194-1200, 1206-1209, 1211, 1215, 1222-1224, 1227, 1234, 1256-1268, 1275-1277, 1302-1311, 1320, 1338, 1359
pi_camera_in_docker/modes/__init__.py                 0      0 100.00%
pi_camera_in_docker/modes/webcam.py                 259     67  74.13%   45-47, 64, 72, 86-88, 93, 108-135, 202, 206-207, 210, 217, 227-228, 253, 259, 263, 270, 280, 282, 291, 302, 315, 319, 332-341, 351-360, 367, 384, 395, 410, 455
pi_camera_in_docker/node_registry.py                276     63  77.17%   61-62, 75-79, 98, 142-143, 147-148, 161-162, 183-184, 188-189, 196-197, 210, 215-216, 220-221, 227-228, 235-236, 244-245, 258-265, 276, 279, 284-285, 314-331, 340, 348-349, 404-405, 411-412, 423
pi_camera_in_docker/runtime_config.py               202     57  71.78%   23-24, 56, 63, 79-96, 109-110, 112, 118-119, 121, 145, 178-179, 181, 213-214, 232-233, 246-248, 251-253, 260-262, 264, 266-268, 275, 277, 300-301, 311-318
pi_camera_in_docker/settings_api.py                  86     20  76.74%   40-41, 55-68, 99, 104, 145-146, 161-170, 240-241
pi_camera_in_docker/settings_schema.py               66     19  71.21%   290, 303, 338, 345, 348, 352, 354, 357, 361, 363, 366, 369, 381-387
pi_camera_in_docker/shared.py                        98      9  90.82%   23, 91, 100-103, 111-112, 137, 201, 245
pi_camera_in_docker/structured_logging.py            29      4  86.21%   36-38, 70-71
pi_camera_in_docker/transport_url_validation.py      31      5  83.87%   9-10, 15, 34, 40
--------------------------------------------------------------------------------
TOTAL                                              2874    816  71.61%
Coverage HTML written to dir htmlcov
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_integration.py::test_health_endpoints_present[/ready-markers1] - AssertionError: Missing marker for /ready: not_ready
assert 'not_ready' in '#!/usr/bin/python3\n\nimport io\nimport logging\nimport os\nimport signal\nimport time\nfrom datetime import datetime, timezone\nfrom pathlib import Path  # Moved here\nfrom threading import Event, RLock, Thread\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import Flask, g, jsonify, render_template, request\nfrom flask_cors import CORS\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom .application_settings import ApplicationSettings\nfrom .cat_gif_generator import CatGifGenerator\nfrom .config_validator import ConfigValidationError, validate_all_config\nfrom .discovery import DiscoveryAnnouncer, build_discovery_payload\nfrom .feature_flags import FeatureFlags, get_feature_flags, is_flag_enabled\nfrom .logging_config import configure_logging\nfrom .management_api import register_management_routes\nfrom .modes.webcam import (\n    ConnectionTracker,\n    FrameBuffer,\n    StreamStats,\n    get_stream_status,\n    import_camera_components,\n    register_management_camera_error_routes,\n    register_webcam_routes,\n)\nfrom .runtime_config import (\n    load_env_config,\n    merge_config_with_settings,\n)\n\n\n# Conditional import for picamera2 - not available in all test environments\ntry:\n    from picamera2 import global_camera_info as _picamera2_global_camera_info\nexcept (ModuleNotFoundError, ImportError):\n    # Fallback when picamera2 is not available (e.g., in CI without hardware)\n    def _picamera2_global_camera_info():\n        return []\n\n\nfrom PIL import Image\nfrom werkzeug.serving import make_server\n\nfrom .settings_api import register_settings_routes\nfrom .shared import register_shared_routes, register_webcam_control_plane_auth\n\n\nALLOWED_APP_MODES = {"webcam", "management"}\nDEFAULT_APP_MODE = "webcam"\n\nconfigure_logging()\nlogger = logging.getLogger(__name__)\n\nfeature_flags: FeatureFlags = get_feature_flags()\nfeature_flags.load()\n\n\ndef _redacted_url_for_logs(url: str) -> str:\n    parts = urlsplit(url)\n    host = parts.hostname or ""\n    if parts.port is not None:\n        host = f"{host}:{parts.port}"\n    return urlunsplit((parts.scheme, host, parts.path, "", ""))\n\n\ndef _parse_resolution(resolution_str: str) -> Tuple[int, int]:\n    parts = resolution_str.split("x")\n    if len(parts) != 2:\n        message = f"Invalid resolution format: {resolution_str}"\n        raise ValueError(message)\n    width, height = int(parts[0]), int(parts[1])\n    if width <= 0 or height <= 0 or width > 4096 or height > 4096:\n        message = f"Resolution dimensions out of valid range (1-4096): {width}x{height}"\n        raise ValueError(message)\n    return width, height\n\n\ndef _load_advanced_config() -> Dict[str, Any]:\n    """Load advanced and hardware-specific configuration."""\n    pi3_profile_raw = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    )\n\n    return {\n        "pi3_profile_enabled": pi3_profile_raw.lower() in ("1", "true", "yes"),\n        "mock_camera": is_flag_enabled("MOCK_CAMERA"),\n        "allow_pykms_mock": os.environ.get("ALLOW_PYKMS_MOCK", "false").lower()\n        in ("1", "true", "yes"),\n        "node_registry_path": os.environ.get("NODE_REGISTRY_PATH", "/data/node-registry.json"),\n        "management_auth_token": os.environ.get("MANAGEMENT_AUTH_TOKEN", ""),\n    }\n\n\ndef _load_config() -> Dict[str, Any]:\n    """Load all configuration from environment variables using helper functions."""\n    return load_env_config()\n\n\ndef _merge_config_with_settings(env_config: Dict[str, Any]) -> Dict[str, Any]:\n    return merge_config_with_settings(env_config)\n\n\ndef _detect_camera_devices() -> Dict[str, Any]:\n    """\n    Detect available camera-related device nodes on the system.\n    Returns a dict with detected device information.\n    Failures are logged but don\'t raise exceptions (graceful fallback).\n    """\n    result: Dict[str, Union[bool, List[str]]] = {\n        "has_camera": False,\n        "video_devices": List[str](),\n        "media_devices": List[str](),\n        "v4l_subdev_devices": List[str](),\n        "dma_heap_devices": List[str](),\n        "vchiq_device": False,\n        "dri_device": False,\n    }\n\n    try:\n        # Check DMA heap devices\n        dma_heap_dir = "/dev/dma_heap"\n        if Path(dma_heap_dir).is_dir():\n            try:\n                dma_devices = [f.name for f in Path(dma_heap_dir).iterdir()]\n                result["dma_heap_devices"] = [f"/dev/dma_heap/{d}" for d in dma_devices]\n            except OSError:\n                logger.debug("Could not list /dev/dma_heap directory")\n\n        # Check video devices\n        for i in range(10):\n            video_device = f"/dev/video{i}"\n            if Path(video_device).exists():\n                result["video_devices"].append(video_device)\n\n        # Check media devices\n        for i in range(10):\n            media_device = f"/dev/media{i}"\n            if Path(media_device).exists():\n                result["media_devices"].append(media_device)\n\n        # Check v4l sub-device nodes\n        for i in range(64):\n            subdev_device = f"/dev/v4l-subdev{i}"\n            if Path(subdev_device).exists():\n                result["v4l_subdev_devices"].append(subdev_device)\n\n        # Check VCHIQ\n        if Path("/dev/vchiq").exists():\n            result["vchiq_device"] = True\n\n        # Check DRI (graphics)\n        if Path("/dev/dri").exists():\n            result["dri_device"] = True\n\n        # Set has_camera flag\n        result["has_camera"] = bool(\n            result["video_devices"]\n            or result["media_devices"]\n            or result["v4l_subdev_devices"]\n            or result["vchiq_device"]\n        )\n    except Exception as e:\n        logger.warning(f"Device detection encountered error: {e}")\n\n    return result\n\n\ndef _collect_current_config() -> Dict[str, Any]:\n    """\n    Collect current configuration from environment variables.\n    Returns a simplified config dict for the setup API.\n    """\n    try:\n        resolution = _parse_resolution(os.environ.get("RESOLUTION", "640x480"))\n    except ValueError:\n        resolution = (640, 480)\n\n    try:\n        fps = int(os.environ.get("FPS", "0"))\n    except ValueError:\n        fps = 0\n\n    try:\n        target_fps_str = os.environ.get("TARGET_FPS", "")\n        target_fps = int(target_fps_str) if target_fps_str else None\n    except ValueError:\n        target_fps = None\n\n    try:\n        jpeg_quality = int(os.environ.get("JPEG_QUALITY", "90"))\n        if not 1 <= jpeg_quality <= 100:\n            jpeg_quality = 90\n    except ValueError:\n        jpeg_quality = 90\n\n    try:\n        max_stream_connections = int(os.environ.get("MAX_STREAM_CONNECTIONS", "10"))\n        if not 1 <= max_stream_connections <= 100:\n            max_stream_connections = 10\n    except ValueError:\n        max_stream_connections = 10\n\n    pi3_profile = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    ).lower() in (\n        "1",\n        "true",\n        "yes",\n    )\n    mock_camera = is_flag_enabled("MOCK_CAMERA")\n    cors_origins = os.environ.get("MOTION_IN_OCEAN_CORS_ORIGINS", "")\n    auth_token = os.environ.get("MANAGEMENT_AUTH_TOKEN", "")\n\n    return {\n        "resolution": f"{resolution[0]}x{resolution[1]}",\n        "fps": fps,\n        "target_fps": target_fps,\n        "jpeg_quality": jpeg_quality,\n        "max_connections": max_stream_connections,\n        "pi3_profile": pi3_profile,\n        "mock_camera": mock_camera,\n        "cors_origins": cors_origins,\n        "auth_token": auth_token,\n    }\n\n\ndef _get_setup_presets() -> Dict[str, Dict[str, Any]]:\n    """\n    Return available setup presets with default values.\n    """\n    return {\n        "pi3_low_power": {\n            "name": "Pi3 Low Power",\n            "description": "Optimized for Raspberry Pi 3 with low resource usage",\n            "resolution": "640x480",\n            "fps": 12,\n            "target_fps": 12,\n            "jpeg_quality": 75,\n            "max_connections": 3,\n            "pi3_profile": True,\n            "mock_camera": False,\n        },\n        "pi5_high_quality": {\n            "name": "Pi5 High Quality",\n            "description": "High quality streaming for Raspberry Pi 5",\n            "resolution": "1280x720",\n            "fps": 24,\n            "target_fps": 24,\n            "jpeg_quality": 90,\n            "max_connections": 10,\n            "pi3_profile": False,\n            "mock_camera": False,\n        },\n    }\n\n\ndef _validate_setup_config(config: Dict[str, Any]) -> Tuple[bool, list]:\n    """\n    Validate setup configuration values.\n    Returns (is_valid, list_of_errors).\n    """\n    errors = []\n\n    # Validate resolution\n    if "resolution" in config:\n        try:\n            _parse_resolution(config["resolution"])\n        except ValueError as e:\n            errors.append(f"Resolution: {e!s}")\n\n    # Validate FPS\n    if "fps" in config:\n        fps = config.get("fps", 0)\n        if not isinstance(fps, int) or fps < 0 or fps > 120:\n            errors.append("FPS must be an integer between 0 and 120")\n\n    # Validate target FPS\n    if "target_fps" in config and config["target_fps"] is not None:\n        target_fps = config["target_fps"]\n        if not isinstance(target_fps, int) or target_fps < 1 or target_fps > 120:\n            errors.append("Target FPS must be an integer between 1 and 120 (or null to disable)")\n\n    # Validate JPEG quality\n    if "jpeg_quality" in config:\n        quality = config.get("jpeg_quality", 90)\n        if not isinstance(quality, int) or quality < 1 or quality > 100:\n            errors.append("JPEG Quality must be between 1 and 100")\n\n    # Validate max connections\n    if "max_connections" in config:\n        conns = config.get("max_connections", 10)\n        if not isinstance(conns, int) or conns < 1 or conns > 100:\n            errors.append("Max Connections must be between 1 and 100")\n\n    return len(errors) == 0, errors\n\n\ndef _generate_docker_compose_content(\n    _config: Dict[str, Any], detected_devices: Dict[str, Any]\n) -> str:\n    """\n    Generate docker-compose.yaml content based on configuration and detected devices.\n    """\n    # Base docker-compose with anchors\n    compose = """# Motion In Ocean Docker Compose Configuration\n# Generated by the Set-Up UI\n\nx-motion-in-ocean-common: &motion-in-ocean-common\n  image: ghcr.io/cyanautomation/motioninocean:latest\n  platform: linux/arm64\n  restart: unless-stopped\n  env_file: ./.env\n  security_opt:\n    - no-new-privileges:true\n  stop_grace_period: 30s\n  logging:\n    driver: json-file\n    options:\n      max-size: "10m"\n      max-file: "3"\n\nx-motion-in-ocean-camera: &motion-in-ocean-camera\n  volumes:\n    - /run/udev:/run/udev:ro\n  devices:\n"""\n\n    # Add detected devices\n    if detected_devices.get("dma_heap_devices"):\n        for device in detected_devices["dma_heap_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("vchiq_device"):\n        compose += "    - /dev/vchiq:/dev/vchiq\\n"\n\n    if detected_devices.get("video_devices"):\n        for device in detected_devices["video_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("media_devices"):\n        for device in detected_devices["media_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("v4l_subdev_devices"):\n        for device in detected_devices["v4l_subdev_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("dri_device"):\n        compose += "    - /dev/dri:/dev/dri\\n"\n\n    compose += """  group_add:\n    - video\n  device_cgroup_rules:\n    - "c 253:* rmw"\n    - "c 511:* rmw"\n    - "c 81:* rmw"\n    - "c 250:* rmw"\n\nservices:\n  motion-in-ocean:\n    <<: [*motion-in-ocean-common, *motion-in-ocean-camera]\n    container_name: motion-in-ocean\n    environment:\n      TZ: ${TZ}\n      APP_MODE: ${MOTION_IN_OCEAN_MODE:-webcam}\n      RESOLUTION: ${MOTION_IN_OCEAN_RESOLUTION}\n      FPS: ${MOTION_IN_OCEAN_FPS}\n      TARGET_FPS: ${MOTION_IN_OCEAN_TARGET_FPS:-}\n      JPEG_QUALITY: ${MOTION_IN_OCEAN_JPEG_QUALITY}\n      MAX_STREAM_CONNECTIONS: ${MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS:-2}\n      # Canonical Pi 3 profile toggle consumed by runtime config loading.\n      MOTION_IN_OCEAN_PI3_PROFILE: ${MOTION_IN_OCEAN_PI3_PROFILE:-false}\n      MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY: ${MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY:-false}\n      CORS_ORIGINS: ${MOTION_IN_OCEAN_CORS_ORIGINS}\n      MOCK_CAMERA: ${MOCK_CAMERA:-false}\n      HEALTHCHECK_READY: ${MOTION_IN_OCEAN_HEALTHCHECK_READY:-true}\n    ports:\n      - "${MOTION_IN_OCEAN_BIND_HOST:-127.0.0.1}:${MOTION_IN_OCEAN_PORT:-8000}:8000"\n    volumes:\n      - motion-in-ocean-data:/data\n    healthcheck:\n      test: ["CMD", "python3", "/app/healthcheck.py"]\n      interval: 2m\n      timeout: 10s\n      retries: 3\n      start_period: 2m\n\nvolumes:\n  motion-in-ocean-data:\n    driver: local\n"""\n    return compose\n\n\ndef _generate_env_content(config: Dict[str, Any]) -> str:\n    """\n    Generate .env content based on configuration.\n    """\n    env_lines = [\n        "# Motion In Ocean Environment Configuration",\n        "# Generated by the Set-Up UI",\n        "",\n        "# Timezone",\n        "TZ=UTC",\n        "",\n        "# Application Mode (webcam or management)",\n        "MOTION_IN_OCEAN_MODE=webcam",\n        "",\n        "# Camera Configuration",\n        f"MOTION_IN_OCEAN_RESOLUTION={config.get(\'resolution\', \'640x480\')}",\n        f"MOTION_IN_OCEAN_FPS={config.get(\'fps\', 0)}",\n        f"MOTION_IN_OCEAN_TARGET_FPS={config.get(\'target_fps\', \'\') or \'\'}",\n        f"MOTION_IN_OCEAN_JPEG_QUALITY={config.get(\'jpeg_quality\', 90)}",\n        f"MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS={config.get(\'max_connections\', 10)}",\n        # Canonical Pi 3 profile env variable consumed by runtime config loading.\n        f"MOTION_IN_OCEAN_PI3_PROFILE={\'true\' if config.get(\'pi3_profile\') else \'false\'}",\n        "",\n        "# Features and Integration",\n        "MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY=false",\n        f"MOTION_IN_OCEAN_CORS_ORIGINS={config.get(\'cors_origins\', \'\')}",\n        f"MOCK_CAMERA={\'true\' if config.get(\'mock_camera\') else \'false\'}",\n        "MOTION_IN_OCEAN_HEALTHCHECK_READY=true",\n        "",\n        "# Networking",\n        "MOTION_IN_OCEAN_BIND_HOST=127.0.0.1",\n        "MOTION_IN_OCEAN_PORT=8000",\n        "MOTION_IN_OCEAN_IMAGE_TAG=latest",\n        "",\n        "# Management/Security",\n        f"MANAGEMENT_AUTH_TOKEN={config.get(\'auth_token\', \'\')}",\n        "",\n    ]\n\n    return "\\n".join(env_lines)\n\n\ndef _init_flask_app(_config: Dict[str, Any]) -> Tuple[Flask, Limiter]:\n    """Initialize Flask app and rate limiter."""\n    app = Flask(__name__, static_folder="static", static_url_path="/static")\n    app.start_time_monotonic = time.monotonic()\n\n    limiter = Limiter(\n        app=app,\n        key_func=get_remote_address,\n        default_limits=["100/minute"],\n        storage_uri=os.environ.get("LIMITER_STORAGE_URI", "memory://"),\n    )\n\n    return app, limiter\n\n\ndef _register_middleware(app: Flask, config: Dict[str, Any]) -> None:\n    """Register middleware for correlation ID, logging, and CORS."""\n\n    # Add correlation ID middleware\n    @app.before_request\n    def _add_correlation_id() -> None:\n        g.correlation_id = (\n            request.headers.get("X-Correlation-ID", request.headers.get("x-correlation-id", ""))\n            or None\n        )\n\n    # Ensure correlation ID is returned in response\n    @app.after_request\n    def _inject_correlation_id(response):\n        if hasattr(g, "correlation_id") and g.correlation_id:\n            response.headers["X-Correlation-ID"] = g.correlation_id\n        return response\n\n    _register_request_logging(app)\n\n    if config["cors_enabled"]:\n        cors_origins_config = config.get("cors_origins", "*")\n\n        if isinstance(cors_origins_config, str):\n            parsed_origins = [\n                origin.strip() for origin in cors_origins_config.split(",") if origin.strip()\n            ]\n            cors_origins = (\n                parsed_origins\n                if len(parsed_origins) > 1\n                else (parsed_origins[0] if parsed_origins else "*")\n            )\n        elif isinstance(cors_origins_config, (list, tuple, set)):\n            parsed_origins = [\n                str(origin).strip() for origin in cors_origins_config if str(origin).strip()\n            ]\n            cors_origins = parsed_origins if parsed_origins else "*"\n        else:\n            cors_origins = "*"\n\n        cors_options = {"resources": {r"/*": {"origins": cors_origins}}}\n        if cors_origins == "*":\n            cors_options["send_wildcard"] = True\n\n        CORS(app, **cors_options)\n\n\ndef _init_app_state(config: Dict[str, Any]) -> dict:\n    """Initialize application state dictionary."""\n    return {\n        "app_mode": config["app_mode"],\n        "recording_started": Event(),\n        "shutdown_requested": Event(),\n        "camera_lock": RLock(),\n        "max_frame_age_seconds": config["max_frame_age_seconds"],\n        "picam2_instance": None,\n        "cat_gif_generator": None,\n    }\n\n\ndef _create_base_app(config: Dict[str, Any]) -> Tuple[Flask, Limiter, dict]:\n    # Initialize Flask app and limiter\n    app, limiter = _init_flask_app(config)\n\n    # Register middleware\n    _register_middleware(app, config)\n\n    # Initialize application state\n    state = _init_app_state(config)\n    app.motion_state = state\n    app.motion_config = dict(config)\n    app.application_settings = ApplicationSettings()  # Add settings persistence\n\n    @app.route("/")\n    def index() -> str:\n        if config["app_mode"] == "management":\n            return render_template("management.html")\n        return render_template(\n            "index.html", width=config["resolution"][0], height=config["resolution"][1]\n        )\n\n    @app.route("/api/config")\n    def api_config():\n        def _indicator(state_value: str, label: str, details: str) -> Dict[str, str]:\n            return {\n                "state": state_value,\n                "label": label,\n                "details": details,\n            }\n\n        def _build_health_check(\n            camera_is_active: bool,\n            stream_status: Dict[str, Any],\n            current_connections_count: int,\n            max_connections_count: int,\n        ) -> Dict[str, Dict[str, str]]:\n            last_frame_age_seconds = stream_status.get("last_frame_age_seconds")\n            max_age_seconds = state.get("max_frame_age_seconds", config["max_frame_age_seconds"])\n\n            if camera_is_active:\n                camera_pipeline = _indicator(\n                    "ok",\n                    "Camera pipeline active",\n                    "Camera recording pipeline is active.",\n                )\n            elif state.get("app_mode") == "management":\n                camera_pipeline = _indicator(\n                    "unknown",\n                    "Camera pipeline not required",\n                    "Management mode does not require an active camera pipeline.",\n                )\n            else:\n                camera_pipeline = _indicator(\n                    "fail",\n                    "Camera pipeline inactive",\n                    "Camera recording pipeline is not active.",\n                )\n\n            if last_frame_age_seconds is None:\n                stream_freshness = _indicator(\n                    "unknown",\n                    "Stream freshness unavailable",\n                    "No frame age is currently available to evaluate freshness.",\n                )\n            elif last_frame_age_seconds <= max_age_seconds:\n                stream_freshness = _indicator(\n                    "ok",\n                    "Stream is fresh",\n                    f"Last frame age {last_frame_age_seconds:.2f}s is within the {max_age_seconds:.2f}s threshold.",\n                )\n            else:\n                stream_freshness = _indicator(\n                    "fail",\n                    "Stream is stale",\n                    f"Last frame age {last_frame_age_seconds:.2f}s exceeds the {max_age_seconds:.2f}s threshold.",\n                )\n\n            connection_ratio = (\n                current_connections_count / max_connections_count\n                if max_connections_count > 0\n                else 0.0\n            )\n            if max_connections_count <= 0:\n                connection_capacity = _indicator(\n                    "unknown",\n                    "Connection capacity unavailable",\n                    "Maximum stream connections is not configured.",\n                )\n            elif connection_ratio >= 1.0:\n                connection_capacity = _indicator(\n                    "fail",\n                    "Connection capacity reached",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            elif connection_ratio >= 0.8:\n                connection_capacity = _indicator(\n                    "warn",\n                    "Connection capacity nearing limit",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            else:\n                connection_capacity = _indicator(\n                    "ok",\n                    "Connection capacity healthy",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n\n            expected_real_camera = state.get("app_mode") == "webcam"\n            if config["mock_camera"] and expected_real_camera:\n                mock_mode = _indicator(\n                    "warn",\n                    "Mock camera enabled",\n                    "Mock camera is enabled while webcam mode is active.",\n                )\n            elif config["mock_camera"]:\n                mock_mode = _indicator(\n                    "ok",\n                    "Mock camera enabled",\n                    "Mock camera is enabled for a non-webcam mode.",\n                )\n            else:\n                mock_mode = _indicator(\n                    "ok",\n                    "Real camera mode",\n                    "Mock camera is disabled.",\n                )\n\n            return {\n                "camera_pipeline": camera_pipeline,\n                "stream_freshness": stream_freshness,\n                "connection_capacity": connection_capacity,\n                "mock_mode": mock_mode,\n            }\n\n        if state.get("app_mode") == "webcam":\n            tracker = state.get("connection_tracker")\n            recording_started = state.get("recording_started")\n            stream_stats = state.get("stream_stats")\n\n            current_connections = (\n                tracker.get_count() if isinstance(tracker, ConnectionTracker) else 0\n            )\n            camera_active = isinstance(recording_started, Event) and recording_started.is_set()\n            stream_status = (\n                get_stream_status(stream_stats, config["resolution"])\n                if isinstance(stream_stats, StreamStats)\n                else {"last_frame_age_seconds": None}\n            )\n            uptime_seconds = round(\n                max(\n                    0.0,\n                    time.monotonic() - getattr(app, "start_time_monotonic", 0.0),\n                ),\n                2,\n            )\n        else:\n            current_connections = 0\n            camera_active = False\n            stream_status = {"last_frame_age_seconds": None}\n            uptime_seconds = None\n\n        max_connections = state.get("max_stream_connections", config["max_stream_connections"])\n        health_check = _build_health_check(\n            camera_active,\n            stream_status,\n            current_connections,\n            max_connections,\n        )\n\n        return jsonify(\n            {\n                "camera_settings": {\n                    "resolution": list(config["resolution"]),\n                    "fps": config["fps"],\n                    "target_fps": config["target_fps"],\n                    "jpeg_quality": config["jpeg_quality"],\n                },\n                "stream_control": {\n                    "max_stream_connections": state.get(\n                        "max_stream_connections", config["max_stream_connections"]\n                    ),\n                    "current_stream_connections": current_connections,\n                    "max_frame_age_seconds": state.get(\n                        "max_frame_age_seconds", config["max_frame_age_seconds"]\n                    ),\n                    "cors_origins": config["cors_origins"],\n                },\n                "runtime": {\n                    "camera_active": camera_active,\n                    "mock_camera": config["mock_camera"],\n                    "uptime_seconds": uptime_seconds,\n                },\n                "health_check": health_check,\n                "timestamp": datetime.now(timezone.utc).isoformat(),\n                "app_mode": config["app_mode"],\n            }\n        ), 200\n\n    @app.route("/api/feature-flags")\n    def api_flags():\n        return jsonify(feature_flags.get_all_flags()), 200\n\n    @app.route("/api/setup/templates", methods=["GET"])\n    def api_setup_templates():\n        """Return setup templates, current config, detected devices, and constraints."""\n        try:\n            current_config = _collect_current_config()\n            detected_devices = _detect_camera_devices()\n            presets = _get_setup_presets()\n\n            return jsonify(\n                {\n                    "current_config": current_config,\n                    "available_presets": presets,\n                    "detected_devices": detected_devices,\n                    "constraints": {\n                        "resolution_examples": ["640x480", "1280x720", "1920x1080"],\n                        "fps_range": [0, 120],\n                        "jpeg_quality_range": [1, 100],\n                        "max_connections_range": [1, 100],\n                    },\n                    "app_mode": config["app_mode"],\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup templates endpoint failed")\n            return jsonify({"error": f"Failed to load setup templates: {e!s}"}), 500\n\n    @app.route("/api/setup/validate", methods=["POST"])\n    def api_setup_validate():\n        """Validate setup configuration values."""\n        try:\n            data = request.get_json() or {}\n            is_valid, errors = _validate_setup_config(data)\n\n            return jsonify(\n                {\n                    "valid": is_valid,\n                    "errors": errors,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup validation endpoint failed")\n            return jsonify({"valid": False, "errors": [f"Validation error: {e!s}"]}), 200\n\n    @app.route("/api/setup/generate", methods=["POST"])\n    def api_setup_generate():\n        """Generate docker-compose.yaml and .env files based on provided configuration."""\n        try:\n            data = request.get_json() or {}\n\n            # Validate first\n            is_valid, errors = _validate_setup_config(data)\n            if not is_valid:\n                error_msg = "; ".join(errors)\n                logger.warning(f"Setup generation validation failed: {error_msg}")\n                return jsonify({"error": f"Configuration invalid: {error_msg}"}), 400\n\n            # Detect devices\n            detected_devices = _detect_camera_devices()\n\n            # Generate files\n            docker_compose_content = _generate_docker_compose_content(data, detected_devices)\n            env_content = _generate_env_content(data)\n\n            return jsonify(\n                {\n                    "docker_compose_yaml": docker_compose_content,\n                    "env_content": env_content,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup generation endpoint failed")\n            return jsonify({"error": f"Failed to generate configuration: {e!s}"}), 500\n\n    # NOTE: The following endpoints are defined in shared.py via register_shared_routes:\n\n\n\n\n    return app, limiter, state\n\n\ndef _register_request_logging(app: Flask) -> None:\n    health_endpoints = {"/health", "/ready"}\n\n    @app.before_request\n    def _track_request_start() -> None:\n        g.request_started_monotonic = time.monotonic()\n\n    @app.after_request\n    def _log_request(response):\n        request_started = getattr(g, "request_started_monotonic", None)\n        latency_ms = 0.0\n        if request_started is not None:\n            latency_ms = (time.monotonic() - request_started) * 1000\n\n        correlation_id = getattr(g, "correlation_id", None) or "none"\n        level = logging.DEBUG if request.path in health_endpoints else logging.INFO\n        logger.log(\n            level,\n            "request correlation_id=%s method=%s path=%s status=%s latency_ms=%.1f",\n            correlation_id,\n            request.method,\n            request.path,\n            response.status_code,\n            latency_ms,\n        )\n        return response\n\n\ndef create_management_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "management"\n    app, limiter, state = _create_base_app(cfg)\n    # Routes registered by these functions:\n    # @app.route("/")  # defined in _create_base_app\n    # @app.route("/health")  # registered in register_shared_routes (shared.py)\n    # @app.route("/ready")  # registered in register_shared_routes (shared.py)\n    register_shared_routes(app, state)\n    register_settings_routes(app)  # Add settings management API\n    register_management_camera_error_routes(app)\n    register_management_routes(\n        app,\n        cfg["node_registry_path"],\n        auth_token=cfg["management_auth_token"],\n        limiter=limiter,\n    )\n    # Log management mode startup configuration\n    logger.info(\n        "management_mode_initialized: auth_required=%s, registry_path=%s",\n        bool(cfg["management_auth_token"]),\n        cfg["node_registry_path"],\n    )\n    return app\n\n\ndef create_webcam_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "webcam"\n    app, _limiter, state = _create_base_app(cfg)\n\n    stream_stats = StreamStats()\n    output = FrameBuffer(stream_stats, target_fps=cfg["target_fps"])\n    state.update(\n        {\n            "output": output,\n            "stream_stats": stream_stats,\n            "connection_tracker": ConnectionTracker(),\n            "max_stream_connections": cfg["max_stream_connections"],\n            "api_test": {\n                "enabled": cfg["api_test_mode_enabled"],\n                "active": cfg["api_test_mode_enabled"],\n                "current_state_index": 0,\n                "scenario_list": [],\n                "last_transition_monotonic": time.monotonic(),\n                "cycle_interval_seconds": cfg["api_test_cycle_interval_seconds"],\n                "lock": RLock(),\n            },\n            "discovery_announcer": None,\n        }\n    )\n\n    default_api_test_scenarios = [\n        {\n            "status": "ok",\n            "stream_available": True,\n            "camera_active": True,\n            "fps": 24.0,\n            "connections": {"current": 1, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": True,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": False,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n    ]\n\n    def _get_api_test_status_override(\n        uptime_seconds: float, max_connections: int\n    ) -> Optional[Dict[str, Any]]:\n        api_test_state = state.get("api_test")\n        if not api_test_state or not api_test_state.get("enabled"):\n            return None\n\n        lock = api_test_state.get("lock")\n        if not lock:\n            return None\n\n        with lock:\n            scenario_list = api_test_state.get("scenario_list") or default_api_test_scenarios\n            if not api_test_state.get("scenario_list"):\n                api_test_state["scenario_list"] = scenario_list\n\n            interval = api_test_state.get("cycle_interval_seconds", 5.0)\n            now = time.monotonic()\n\n            if (\n                api_test_state.get("active")\n                and interval > 0\n                and now - api_test_state.get("last_transition_monotonic", now) >= interval\n            ):\n                api_test_state["current_state_index"] = (\n                    api_test_state.get("current_state_index", 0) + 1\n                ) % len(scenario_list)\n                api_test_state["last_transition_monotonic"] = now\n\n            current_state_index = api_test_state.get("current_state_index", 0) % len(scenario_list)\n            scenario = scenario_list[current_state_index]\n            state_name = scenario.get("status", f"state-{current_state_index}")\n\n            next_transition_seconds = None\n            if api_test_state.get("active") and interval > 0:\n                elapsed = max(0.0, now - api_test_state.get("last_transition_monotonic", now))\n                next_transition_seconds = round(max(0.0, interval - elapsed), 3)\n\n        return {\n            "status": scenario["status"],\n            "app_mode": state["app_mode"],\n            "stream_available": scenario["stream_available"],\n            "camera_active": scenario["camera_active"],\n            "uptime_seconds": uptime_seconds,\n            "fps": scenario["fps"],\n            "connections": {\n                "current": scenario["connections"]["current"],\n                "max": max_connections,\n            },\n            "timestamp": datetime.now(timezone.utc).isoformat(),\n            "api_test": {\n                "enabled": api_test_state.get("enabled", False),\n                "active": api_test_state.get("active", False),\n                "state_index": current_state_index,\n                "state_name": state_name,\n                "next_transition_seconds": next_transition_seconds,\n            },\n        }\n\n    register_shared_routes(\n        app,\n        state,\n        get_stream_status=lambda: get_stream_status(stream_stats, cfg["resolution"]),\n        get_api_test_status_override=_get_api_test_status_override,\n    )\n    register_settings_routes(app)  # Add settings management API\n    register_webcam_control_plane_auth(\n        app,\n        cfg["management_auth_token"],\n        app_mode_provider=lambda: state["app_mode"],\n    )\n    # Routes registered by register_webcam_routes:\n    # @app.route("/stream.mjpg")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam/")  # registered in register_webcam_routes (modes/webcam.py)\n    register_webcam_routes(app, state, is_flag_enabled=is_flag_enabled)\n    _run_webcam_mode(state, cfg)\n\n    if cfg["discovery_enabled"]:\n        if not cfg["discovery_token"]:\n            logger.warning("Discovery enabled but DISCOVERY_TOKEN is empty; announcer disabled")\n        else:\n            try:\n                discovery_cfg = {\n                    "discovery_node_id": cfg["discovery_node_id"],\n                    "discovery_base_url": cfg["base_url"],\n                }\n                payload = build_discovery_payload(discovery_cfg)\n                announcer = DiscoveryAnnouncer(\n                    management_url=cfg["discovery_management_url"],\n                    token=cfg["discovery_token"],\n                    interval_seconds=cfg["discovery_interval_seconds"],\n                    node_id=payload["node_id"],\n                    payload=payload,\n                    shutdown_event=state["shutdown_requested"],\n                )\n                announcer.start()\n                state["discovery_announcer"] = announcer\n                logger.info(\n                    "discovery_announcer_started: node_id=%s management_url=%s interval_seconds=%.1f",\n                    payload["node_id"],\n                    _redacted_url_for_logs(cfg["discovery_management_url"]),\n                    cfg["discovery_interval_seconds"],\n                )\n            except Exception:\n                logger.exception("Failed to initialize discovery announcer")\n    return app\n\n\ndef create_app_from_env() -> Flask:\n    cfg = _load_config()\n    try:\n        validate_all_config(cfg)\n    except ConfigValidationError as e:\n        error_msg = str(e)\n        if e.hint:\n            error_msg += f" ({e.hint})"\n        logger.error("Configuration validation failed: %s", error_msg)\n        raise ValueError(error_msg) from e\n\n    app = create_management_app(cfg) if cfg["app_mode"] == "management" else create_webcam_app(cfg)\n    logger.info("Application started in %s mode", cfg["app_mode"])\n    return app\n\n\ndef _check_device_availability(cfg: Dict[str, Any]) -> None:\n    """Validate that required camera device nodes exist before initialization."""\n    if cfg["mock_camera"]:\n        return\n\n    required_devices = ["/dev/vchiq"]\n    device_patterns = {\n        "video": range(10),  # /dev/video0 through /dev/video9\n        "media": range(10),  # /dev/media0 through /dev/media9\n        "v4l_subdev": range(64),  # /dev/v4l-subdev0 through /dev/v4l-subdev63\n        "dma_heap": ["system", "linux,cma"],  # Common dma_heap device names\n    }\n\n    device_pattern_display = {\n        "video": "/dev/video*",\n        "media": "/dev/media*",\n        "v4l_subdev": "/dev/v4l-subdev*",\n        "dma_heap": "/dev/dma_heap/*",\n    }\n\n    discovered_nodes = {\n        "video": [\n            Path(f"/dev/video{i}")\n            for i in device_patterns["video"]\n            if Path(f"/dev/video{i}").exists()\n        ],\n        "media": [\n            Path(f"/dev/media{i}")\n            for i in device_patterns["media"]\n            if Path(f"/dev/media{i}").exists()\n        ],\n        "v4l_subdev": [\n            Path(f"/dev/v4l-subdev{i}")\n            for i in device_patterns["v4l_subdev"]\n            if Path(f"/dev/v4l-subdev{i}").exists()\n        ],\n        "dma_heap": [\n            Path(f"/dev/dma_heap/{name}")\n            for name in device_patterns["dma_heap"]\n            if Path(f"/dev/dma_heap/{name}").exists()\n        ],\n    }\n\n    preflight_summary = {\n        "counts": {name: len(paths) for name, paths in discovered_nodes.items()},\n        "samples": {name: paths[:3] for name, paths in discovered_nodes.items()},\n    }\n    logger.info("Camera preflight device summary: %s", preflight_summary)\n\n    missing_critical = [device for device in required_devices if not Path(device).exists()]\n\n    if missing_critical:\n        logger.warning(\n            "Critical camera devices not found: %s. "\n            "Check device mappings in docker-compose.yaml and run ./detect-devices.sh on host.",\n            ", ".join(missing_critical),\n        )\n\n    if not (\n        discovered_nodes["video"] or discovered_nodes["media"] or discovered_nodes["v4l_subdev"]\n    ):\n        logger.warning(\n            "No /dev/video*, /dev/media*, or /dev/v4l-subdev* nodes were detected during preflight. "\n            "Camera enumeration is likely to fail in this container. "\n            "Verify host camera drivers and container device mappings."\n        )\n    elif not discovered_nodes["video"]:\n        missing_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if not discovered_nodes[group_name]\n        ]\n        present_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if discovered_nodes[group_name]\n        ]\n        logger.warning(\n            "Camera device preflight found partial node availability. Present groups: %s. "\n            "Missing groups: %s. Streaming is likely unavailable; verify device mappings and driver state.",\n            ", ".join(present_node_groups),\n            ", ".join(missing_node_groups),\n        )\n\n\ndef _shutdown_camera(state: Dict[str, Any]) -> None:\n    shutdown_requested: Optional[Event] = state.get("shutdown_requested")\n    if shutdown_requested is not None:\n        shutdown_requested.set()\n\n    recording_started: Optional[Event] = state.get("recording_started")\n    if recording_started is not None:\n        recording_started.clear()\n\n    camera_lock: Optional[RLock] = state.get("camera_lock")\n    if camera_lock is None:\n        logger.warning("Camera lock not found in shutdown state")\n        return\n\n    with camera_lock:\n        picam2_instance = state.get("picam2_instance")\n        if picam2_instance is None:\n            return\n\n        try:\n            if getattr(picam2_instance, "started", False):\n                picam2_instance.stop_recording()  # stop_recording marker\n        except Exception:\n            logger.exception("Failed to stop camera recording during shutdown")\n        finally:\n            state["picam2_instance"] = None\n\n\ndef _get_camera_info(picamera2_cls: Any) -> Tuple[list, str]:\n    try:\n        return _picamera2_global_camera_info(), "picamera2.global_camera_info"\n    except (ImportError, AttributeError, NameError):\n        logger.debug(\n            "picamera2.global_camera_info import unavailable; falling back to Picamera2 class method"\n        )\n\n    class_global_camera_info = getattr(picamera2_cls, "global_camera_info", None)\n    if callable(class_global_camera_info):\n        try:\n            return class_global_camera_info(), "Picamera2.global_camera_info"\n        except Exception:\n            logger.debug("Picamera2.global_camera_info call failed at runtime")\n\n    logger.warning(\n        "Unable to query camera inventory from picamera2. Proceeding with empty camera list. "\n        "If camera detection fails, verify the installed picamera2 version supports global_camera_info."\n    )\n    return [], "none"\n\n\ndef _init_mock_camera_frames(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize mock camera frame generation."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n\n    if cfg["cat_gif_enabled"]:\n        # Use cat GIF streaming mode\n        cat_generator = CatGifGenerator(\n            api_url=cfg["cataas_api_url"],\n            resolution=cfg["resolution"],\n            jpeg_quality=cfg["jpeg_quality"],\n            target_fps=cfg["fps"] if cfg["fps"] > 0 else 10,\n            cache_ttl_seconds=cfg["cat_gif_cache_ttl_seconds"],\n        )\n        state["cat_gif_generator"] = cat_generator\n\n        def generate_cat_gif_frames() -> None:\n            recording_started.set()\n            try:\n                for frame in cat_generator.generate_frames():\n                    if shutdown_requested.is_set():\n                        break\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_cat_gif_frames, daemon=True).start()\n    else:\n        # Use classic black frame mock mode\n        fallback = Image.new("RGB", cfg["resolution"], color=(0, 0, 0))\n        buf = io.BytesIO()\n        fallback.save(buf, format="JPEG", quality=cfg["jpeg_quality"])\n        frame = buf.getvalue()\n\n        def generate_mock_frames() -> None:\n            recording_started.set()\n            try:\n                while not shutdown_requested.is_set():\n                    time.sleep(1 / (cfg["fps"] if cfg["fps"] > 0 else 10))\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_mock_frames, daemon=True).start()\n\n\ndef _init_real_camera(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize real camera recording."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n    camera_lock: RLock = state["camera_lock"]\n\n    picamera2_cls, jpeg_encoder_cls, file_output_cls = import_camera_components(\n        cfg["allow_pykms_mock"]\n    )\n    try:\n        # Detect available cameras before initialization\n        try:\n            detected_devices = _detect_camera_devices()\n            camera_inventory = {\n                "video_devices": detected_devices.get("video_devices", []),\n                "media_devices": detected_devices.get("media_devices", []),\n                "v4l_subdev_devices": detected_devices.get("v4l_subdev_devices", []),\n                "dma_heap_devices": detected_devices.get("dma_heap_devices", []),\n                "vchiq_exists": detected_devices.get("vchiq_device", False),\n            }\n            camera_info, detection_path = _get_camera_info(\n                picamera2_cls\n            )  # global_camera_info() marker\n            logger.info("Camera inventory detection path: %s", detection_path)\n            if not camera_info:\n                logger.error(\n                    "No cameras detected by picamera2 enumeration",\n                    extra={\n                        "camera_info_detection_path": detection_path,\n                        "camera_device_inventory": camera_inventory,\n                    },\n                )\n                message = "No cameras detected. Check device mappings and camera hardware."\n                raise RuntimeError(message)\n            logger.info(f"Detected {len(camera_info)} camera(s) available")\n        except IndexError as e:  # except IndexError marker for camera detection\n            message = (\n                "Camera enumeration failed. Verify device mappings and permissions. "\n                "See ./detect-devices.sh and docker-compose.yaml for configuration."\n            )\n            raise RuntimeError(message) from e\n\n        with camera_lock:\n            if shutdown_requested.is_set():\n                message = "Shutdown requested before camera startup completed"\n                raise RuntimeError(message)\n\n            picam2_instance = picamera2_cls()  # Picamera2() marker\n            state["picam2_instance"] = picam2_instance\n            video_config = picam2_instance.create_video_configuration(\n                main={"size": cfg["resolution"], "format": "BGR888"}\n            )  # create_video_configuration marker\n            picam2_instance.configure(video_config)\n            picam2_instance.start_recording(\n                jpeg_encoder_cls(q=cfg["jpeg_quality"]), file_output_cls(output)\n            )  # start_recording marker\n        recording_started.set()\n    except PermissionError as e:  # except PermissionError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Permission denied accessing camera device. Check device mappings in "\n            "docker-compose.yaml and run ./detect-devices.sh on the host for guidance.",\n            exc_info=e,\n        )\n        raise\n    except RuntimeError as e:  # except RuntimeError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Camera initialization failed. This may indicate missing device mappings, "\n            "insufficient permissions, or unavailable hardware. "\n            "See ./detect-devices.sh and docker-compose.yaml for troubleshooting.",\n            exc_info=e,\n        )\n        raise\n    except Exception as e:  # except Exception marker\n        _shutdown_camera(state)\n        logger.error(\n            "Unexpected error during camera initialization. "\n            "Check device availability and permissions.",\n            exc_info=e,\n        )\n        raise\n\n\ndef _run_webcam_mode(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    # Picamera2() / create_video_configuration / start_recording markers are intentionally preserved.\n\n    # Validate device availability early\n    _check_device_availability(cfg)\n\n    if cfg["mock_camera"]:\n        _init_mock_camera_frames(state, cfg)\n    else:\n        _init_real_camera(state, cfg)\n\n\ndef handle_shutdown(app: Flask, signum: int, _frame: Optional[object]) -> None:\n    app_state = getattr(app, "motion_state", None)\n    if isinstance(app_state, dict):\n        announcer = app_state.get("discovery_announcer")\n        if announcer is not None:\n            announcer.stop()\n        _shutdown_camera(app_state)\n    raise SystemExit(signum)\n\n\nif __name__ == "__main__":\n    app = create_app_from_env()\n    signal.signal(signal.SIGTERM, lambda signum, frame: handle_shutdown(app, signum, frame))\n    signal.signal(signal.SIGINT, lambda signum, frame: handle_shutdown(app, signum, frame))\n    # app.run marker preserved for compatibility checks with static tests.\n    server = make_server(\n        app.motion_config["bind_host"], app.motion_config["bind_port"], app, threaded=True\n    )\n    server.serve_forever()\n'
FAILED tests/test_integration.py::test_health_endpoints_present[/metrics-markers2] - AssertionError: Missing marker for /metrics: @app.route("/metrics")
assert '@app.route("/metrics")' in '#!/usr/bin/python3\n\nimport io\nimport logging\nimport os\nimport signal\nimport time\nfrom datetime import datetime, timezone\nfrom pathlib import Path  # Moved here\nfrom threading import Event, RLock, Thread\nfrom typing import Any, Dict, List, Optional, Tuple, Union\nfrom urllib.parse import urlsplit, urlunsplit\n\nfrom flask import Flask, g, jsonify, render_template, request\nfrom flask_cors import CORS\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\n\nfrom .application_settings import ApplicationSettings\nfrom .cat_gif_generator import CatGifGenerator\nfrom .config_validator import ConfigValidationError, validate_all_config\nfrom .discovery import DiscoveryAnnouncer, build_discovery_payload\nfrom .feature_flags import FeatureFlags, get_feature_flags, is_flag_enabled\nfrom .logging_config import configure_logging\nfrom .management_api import register_management_routes\nfrom .modes.webcam import (\n    ConnectionTracker,\n    FrameBuffer,\n    StreamStats,\n    get_stream_status,\n    import_camera_components,\n    register_management_camera_error_routes,\n    register_webcam_routes,\n)\nfrom .runtime_config import (\n    load_env_config,\n    merge_config_with_settings,\n)\n\n\n# Conditional import for picamera2 - not available in all test environments\ntry:\n    from picamera2 import global_camera_info as _picamera2_global_camera_info\nexcept (ModuleNotFoundError, ImportError):\n    # Fallback when picamera2 is not available (e.g., in CI without hardware)\n    def _picamera2_global_camera_info():\n        return []\n\n\nfrom PIL import Image\nfrom werkzeug.serving import make_server\n\nfrom .settings_api import register_settings_routes\nfrom .shared import register_shared_routes, register_webcam_control_plane_auth\n\n\nALLOWED_APP_MODES = {"webcam", "management"}\nDEFAULT_APP_MODE = "webcam"\n\nconfigure_logging()\nlogger = logging.getLogger(__name__)\n\nfeature_flags: FeatureFlags = get_feature_flags()\nfeature_flags.load()\n\n\ndef _redacted_url_for_logs(url: str) -> str:\n    parts = urlsplit(url)\n    host = parts.hostname or ""\n    if parts.port is not None:\n        host = f"{host}:{parts.port}"\n    return urlunsplit((parts.scheme, host, parts.path, "", ""))\n\n\ndef _parse_resolution(resolution_str: str) -> Tuple[int, int]:\n    parts = resolution_str.split("x")\n    if len(parts) != 2:\n        message = f"Invalid resolution format: {resolution_str}"\n        raise ValueError(message)\n    width, height = int(parts[0]), int(parts[1])\n    if width <= 0 or height <= 0 or width > 4096 or height > 4096:\n        message = f"Resolution dimensions out of valid range (1-4096): {width}x{height}"\n        raise ValueError(message)\n    return width, height\n\n\ndef _load_advanced_config() -> Dict[str, Any]:\n    """Load advanced and hardware-specific configuration."""\n    pi3_profile_raw = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    )\n\n    return {\n        "pi3_profile_enabled": pi3_profile_raw.lower() in ("1", "true", "yes"),\n        "mock_camera": is_flag_enabled("MOCK_CAMERA"),\n        "allow_pykms_mock": os.environ.get("ALLOW_PYKMS_MOCK", "false").lower()\n        in ("1", "true", "yes"),\n        "node_registry_path": os.environ.get("NODE_REGISTRY_PATH", "/data/node-registry.json"),\n        "management_auth_token": os.environ.get("MANAGEMENT_AUTH_TOKEN", ""),\n    }\n\n\ndef _load_config() -> Dict[str, Any]:\n    """Load all configuration from environment variables using helper functions."""\n    return load_env_config()\n\n\ndef _merge_config_with_settings(env_config: Dict[str, Any]) -> Dict[str, Any]:\n    return merge_config_with_settings(env_config)\n\n\ndef _detect_camera_devices() -> Dict[str, Any]:\n    """\n    Detect available camera-related device nodes on the system.\n    Returns a dict with detected device information.\n    Failures are logged but don\'t raise exceptions (graceful fallback).\n    """\n    result: Dict[str, Union[bool, List[str]]] = {\n        "has_camera": False,\n        "video_devices": List[str](),\n        "media_devices": List[str](),\n        "v4l_subdev_devices": List[str](),\n        "dma_heap_devices": List[str](),\n        "vchiq_device": False,\n        "dri_device": False,\n    }\n\n    try:\n        # Check DMA heap devices\n        dma_heap_dir = "/dev/dma_heap"\n        if Path(dma_heap_dir).is_dir():\n            try:\n                dma_devices = [f.name for f in Path(dma_heap_dir).iterdir()]\n                result["dma_heap_devices"] = [f"/dev/dma_heap/{d}" for d in dma_devices]\n            except OSError:\n                logger.debug("Could not list /dev/dma_heap directory")\n\n        # Check video devices\n        for i in range(10):\n            video_device = f"/dev/video{i}"\n            if Path(video_device).exists():\n                result["video_devices"].append(video_device)\n\n        # Check media devices\n        for i in range(10):\n            media_device = f"/dev/media{i}"\n            if Path(media_device).exists():\n                result["media_devices"].append(media_device)\n\n        # Check v4l sub-device nodes\n        for i in range(64):\n            subdev_device = f"/dev/v4l-subdev{i}"\n            if Path(subdev_device).exists():\n                result["v4l_subdev_devices"].append(subdev_device)\n\n        # Check VCHIQ\n        if Path("/dev/vchiq").exists():\n            result["vchiq_device"] = True\n\n        # Check DRI (graphics)\n        if Path("/dev/dri").exists():\n            result["dri_device"] = True\n\n        # Set has_camera flag\n        result["has_camera"] = bool(\n            result["video_devices"]\n            or result["media_devices"]\n            or result["v4l_subdev_devices"]\n            or result["vchiq_device"]\n        )\n    except Exception as e:\n        logger.warning(f"Device detection encountered error: {e}")\n\n    return result\n\n\ndef _collect_current_config() -> Dict[str, Any]:\n    """\n    Collect current configuration from environment variables.\n    Returns a simplified config dict for the setup API.\n    """\n    try:\n        resolution = _parse_resolution(os.environ.get("RESOLUTION", "640x480"))\n    except ValueError:\n        resolution = (640, 480)\n\n    try:\n        fps = int(os.environ.get("FPS", "0"))\n    except ValueError:\n        fps = 0\n\n    try:\n        target_fps_str = os.environ.get("TARGET_FPS", "")\n        target_fps = int(target_fps_str) if target_fps_str else None\n    except ValueError:\n        target_fps = None\n\n    try:\n        jpeg_quality = int(os.environ.get("JPEG_QUALITY", "90"))\n        if not 1 <= jpeg_quality <= 100:\n            jpeg_quality = 90\n    except ValueError:\n        jpeg_quality = 90\n\n    try:\n        max_stream_connections = int(os.environ.get("MAX_STREAM_CONNECTIONS", "10"))\n        if not 1 <= max_stream_connections <= 100:\n            max_stream_connections = 10\n    except ValueError:\n        max_stream_connections = 10\n\n    pi3_profile = os.environ.get(\n        "MOTION_IN_OCEAN_PI3_PROFILE", os.environ.get("PI3_PROFILE", "false")\n    ).lower() in (\n        "1",\n        "true",\n        "yes",\n    )\n    mock_camera = is_flag_enabled("MOCK_CAMERA")\n    cors_origins = os.environ.get("MOTION_IN_OCEAN_CORS_ORIGINS", "")\n    auth_token = os.environ.get("MANAGEMENT_AUTH_TOKEN", "")\n\n    return {\n        "resolution": f"{resolution[0]}x{resolution[1]}",\n        "fps": fps,\n        "target_fps": target_fps,\n        "jpeg_quality": jpeg_quality,\n        "max_connections": max_stream_connections,\n        "pi3_profile": pi3_profile,\n        "mock_camera": mock_camera,\n        "cors_origins": cors_origins,\n        "auth_token": auth_token,\n    }\n\n\ndef _get_setup_presets() -> Dict[str, Dict[str, Any]]:\n    """\n    Return available setup presets with default values.\n    """\n    return {\n        "pi3_low_power": {\n            "name": "Pi3 Low Power",\n            "description": "Optimized for Raspberry Pi 3 with low resource usage",\n            "resolution": "640x480",\n            "fps": 12,\n            "target_fps": 12,\n            "jpeg_quality": 75,\n            "max_connections": 3,\n            "pi3_profile": True,\n            "mock_camera": False,\n        },\n        "pi5_high_quality": {\n            "name": "Pi5 High Quality",\n            "description": "High quality streaming for Raspberry Pi 5",\n            "resolution": "1280x720",\n            "fps": 24,\n            "target_fps": 24,\n            "jpeg_quality": 90,\n            "max_connections": 10,\n            "pi3_profile": False,\n            "mock_camera": False,\n        },\n    }\n\n\ndef _validate_setup_config(config: Dict[str, Any]) -> Tuple[bool, list]:\n    """\n    Validate setup configuration values.\n    Returns (is_valid, list_of_errors).\n    """\n    errors = []\n\n    # Validate resolution\n    if "resolution" in config:\n        try:\n            _parse_resolution(config["resolution"])\n        except ValueError as e:\n            errors.append(f"Resolution: {e!s}")\n\n    # Validate FPS\n    if "fps" in config:\n        fps = config.get("fps", 0)\n        if not isinstance(fps, int) or fps < 0 or fps > 120:\n            errors.append("FPS must be an integer between 0 and 120")\n\n    # Validate target FPS\n    if "target_fps" in config and config["target_fps"] is not None:\n        target_fps = config["target_fps"]\n        if not isinstance(target_fps, int) or target_fps < 1 or target_fps > 120:\n            errors.append("Target FPS must be an integer between 1 and 120 (or null to disable)")\n\n    # Validate JPEG quality\n    if "jpeg_quality" in config:\n        quality = config.get("jpeg_quality", 90)\n        if not isinstance(quality, int) or quality < 1 or quality > 100:\n            errors.append("JPEG Quality must be between 1 and 100")\n\n    # Validate max connections\n    if "max_connections" in config:\n        conns = config.get("max_connections", 10)\n        if not isinstance(conns, int) or conns < 1 or conns > 100:\n            errors.append("Max Connections must be between 1 and 100")\n\n    return len(errors) == 0, errors\n\n\ndef _generate_docker_compose_content(\n    _config: Dict[str, Any], detected_devices: Dict[str, Any]\n) -> str:\n    """\n    Generate docker-compose.yaml content based on configuration and detected devices.\n    """\n    # Base docker-compose with anchors\n    compose = """# Motion In Ocean Docker Compose Configuration\n# Generated by the Set-Up UI\n\nx-motion-in-ocean-common: &motion-in-ocean-common\n  image: ghcr.io/cyanautomation/motioninocean:latest\n  platform: linux/arm64\n  restart: unless-stopped\n  env_file: ./.env\n  security_opt:\n    - no-new-privileges:true\n  stop_grace_period: 30s\n  logging:\n    driver: json-file\n    options:\n      max-size: "10m"\n      max-file: "3"\n\nx-motion-in-ocean-camera: &motion-in-ocean-camera\n  volumes:\n    - /run/udev:/run/udev:ro\n  devices:\n"""\n\n    # Add detected devices\n    if detected_devices.get("dma_heap_devices"):\n        for device in detected_devices["dma_heap_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("vchiq_device"):\n        compose += "    - /dev/vchiq:/dev/vchiq\\n"\n\n    if detected_devices.get("video_devices"):\n        for device in detected_devices["video_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("media_devices"):\n        for device in detected_devices["media_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("v4l_subdev_devices"):\n        for device in detected_devices["v4l_subdev_devices"]:\n            compose += f"    - {device}:{device}\\n"\n\n    if detected_devices.get("dri_device"):\n        compose += "    - /dev/dri:/dev/dri\\n"\n\n    compose += """  group_add:\n    - video\n  device_cgroup_rules:\n    - "c 253:* rmw"\n    - "c 511:* rmw"\n    - "c 81:* rmw"\n    - "c 250:* rmw"\n\nservices:\n  motion-in-ocean:\n    <<: [*motion-in-ocean-common, *motion-in-ocean-camera]\n    container_name: motion-in-ocean\n    environment:\n      TZ: ${TZ}\n      APP_MODE: ${MOTION_IN_OCEAN_MODE:-webcam}\n      RESOLUTION: ${MOTION_IN_OCEAN_RESOLUTION}\n      FPS: ${MOTION_IN_OCEAN_FPS}\n      TARGET_FPS: ${MOTION_IN_OCEAN_TARGET_FPS:-}\n      JPEG_QUALITY: ${MOTION_IN_OCEAN_JPEG_QUALITY}\n      MAX_STREAM_CONNECTIONS: ${MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS:-2}\n      # Canonical Pi 3 profile toggle consumed by runtime config loading.\n      MOTION_IN_OCEAN_PI3_PROFILE: ${MOTION_IN_OCEAN_PI3_PROFILE:-false}\n      MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY: ${MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY:-false}\n      CORS_ORIGINS: ${MOTION_IN_OCEAN_CORS_ORIGINS}\n      MOCK_CAMERA: ${MOCK_CAMERA:-false}\n      HEALTHCHECK_READY: ${MOTION_IN_OCEAN_HEALTHCHECK_READY:-true}\n    ports:\n      - "${MOTION_IN_OCEAN_BIND_HOST:-127.0.0.1}:${MOTION_IN_OCEAN_PORT:-8000}:8000"\n    volumes:\n      - motion-in-ocean-data:/data\n    healthcheck:\n      test: ["CMD", "python3", "/app/healthcheck.py"]\n      interval: 2m\n      timeout: 10s\n      retries: 3\n      start_period: 2m\n\nvolumes:\n  motion-in-ocean-data:\n    driver: local\n"""\n    return compose\n\n\ndef _generate_env_content(config: Dict[str, Any]) -> str:\n    """\n    Generate .env content based on configuration.\n    """\n    env_lines = [\n        "# Motion In Ocean Environment Configuration",\n        "# Generated by the Set-Up UI",\n        "",\n        "# Timezone",\n        "TZ=UTC",\n        "",\n        "# Application Mode (webcam or management)",\n        "MOTION_IN_OCEAN_MODE=webcam",\n        "",\n        "# Camera Configuration",\n        f"MOTION_IN_OCEAN_RESOLUTION={config.get(\'resolution\', \'640x480\')}",\n        f"MOTION_IN_OCEAN_FPS={config.get(\'fps\', 0)}",\n        f"MOTION_IN_OCEAN_TARGET_FPS={config.get(\'target_fps\', \'\') or \'\'}",\n        f"MOTION_IN_OCEAN_JPEG_QUALITY={config.get(\'jpeg_quality\', 90)}",\n        f"MOTION_IN_OCEAN_MAX_STREAM_CONNECTIONS={config.get(\'max_connections\', 10)}",\n        # Canonical Pi 3 profile env variable consumed by runtime config loading.\n        f"MOTION_IN_OCEAN_PI3_PROFILE={\'true\' if config.get(\'pi3_profile\') else \'false\'}",\n        "",\n        "# Features and Integration",\n        "MOTION_IN_OCEAN_OCTOPRINT_COMPATIBILITY=false",\n        f"MOTION_IN_OCEAN_CORS_ORIGINS={config.get(\'cors_origins\', \'\')}",\n        f"MOCK_CAMERA={\'true\' if config.get(\'mock_camera\') else \'false\'}",\n        "MOTION_IN_OCEAN_HEALTHCHECK_READY=true",\n        "",\n        "# Networking",\n        "MOTION_IN_OCEAN_BIND_HOST=127.0.0.1",\n        "MOTION_IN_OCEAN_PORT=8000",\n        "MOTION_IN_OCEAN_IMAGE_TAG=latest",\n        "",\n        "# Management/Security",\n        f"MANAGEMENT_AUTH_TOKEN={config.get(\'auth_token\', \'\')}",\n        "",\n    ]\n\n    return "\\n".join(env_lines)\n\n\ndef _init_flask_app(_config: Dict[str, Any]) -> Tuple[Flask, Limiter]:\n    """Initialize Flask app and rate limiter."""\n    app = Flask(__name__, static_folder="static", static_url_path="/static")\n    app.start_time_monotonic = time.monotonic()\n\n    limiter = Limiter(\n        app=app,\n        key_func=get_remote_address,\n        default_limits=["100/minute"],\n        storage_uri=os.environ.get("LIMITER_STORAGE_URI", "memory://"),\n    )\n\n    return app, limiter\n\n\ndef _register_middleware(app: Flask, config: Dict[str, Any]) -> None:\n    """Register middleware for correlation ID, logging, and CORS."""\n\n    # Add correlation ID middleware\n    @app.before_request\n    def _add_correlation_id() -> None:\n        g.correlation_id = (\n            request.headers.get("X-Correlation-ID", request.headers.get("x-correlation-id", ""))\n            or None\n        )\n\n    # Ensure correlation ID is returned in response\n    @app.after_request\n    def _inject_correlation_id(response):\n        if hasattr(g, "correlation_id") and g.correlation_id:\n            response.headers["X-Correlation-ID"] = g.correlation_id\n        return response\n\n    _register_request_logging(app)\n\n    if config["cors_enabled"]:\n        cors_origins_config = config.get("cors_origins", "*")\n\n        if isinstance(cors_origins_config, str):\n            parsed_origins = [\n                origin.strip() for origin in cors_origins_config.split(",") if origin.strip()\n            ]\n            cors_origins = (\n                parsed_origins\n                if len(parsed_origins) > 1\n                else (parsed_origins[0] if parsed_origins else "*")\n            )\n        elif isinstance(cors_origins_config, (list, tuple, set)):\n            parsed_origins = [\n                str(origin).strip() for origin in cors_origins_config if str(origin).strip()\n            ]\n            cors_origins = parsed_origins if parsed_origins else "*"\n        else:\n            cors_origins = "*"\n\n        cors_options = {"resources": {r"/*": {"origins": cors_origins}}}\n        if cors_origins == "*":\n            cors_options["send_wildcard"] = True\n\n        CORS(app, **cors_options)\n\n\ndef _init_app_state(config: Dict[str, Any]) -> dict:\n    """Initialize application state dictionary."""\n    return {\n        "app_mode": config["app_mode"],\n        "recording_started": Event(),\n        "shutdown_requested": Event(),\n        "camera_lock": RLock(),\n        "max_frame_age_seconds": config["max_frame_age_seconds"],\n        "picam2_instance": None,\n        "cat_gif_generator": None,\n    }\n\n\ndef _create_base_app(config: Dict[str, Any]) -> Tuple[Flask, Limiter, dict]:\n    # Initialize Flask app and limiter\n    app, limiter = _init_flask_app(config)\n\n    # Register middleware\n    _register_middleware(app, config)\n\n    # Initialize application state\n    state = _init_app_state(config)\n    app.motion_state = state\n    app.motion_config = dict(config)\n    app.application_settings = ApplicationSettings()  # Add settings persistence\n\n    @app.route("/")\n    def index() -> str:\n        if config["app_mode"] == "management":\n            return render_template("management.html")\n        return render_template(\n            "index.html", width=config["resolution"][0], height=config["resolution"][1]\n        )\n\n    @app.route("/api/config")\n    def api_config():\n        def _indicator(state_value: str, label: str, details: str) -> Dict[str, str]:\n            return {\n                "state": state_value,\n                "label": label,\n                "details": details,\n            }\n\n        def _build_health_check(\n            camera_is_active: bool,\n            stream_status: Dict[str, Any],\n            current_connections_count: int,\n            max_connections_count: int,\n        ) -> Dict[str, Dict[str, str]]:\n            last_frame_age_seconds = stream_status.get("last_frame_age_seconds")\n            max_age_seconds = state.get("max_frame_age_seconds", config["max_frame_age_seconds"])\n\n            if camera_is_active:\n                camera_pipeline = _indicator(\n                    "ok",\n                    "Camera pipeline active",\n                    "Camera recording pipeline is active.",\n                )\n            elif state.get("app_mode") == "management":\n                camera_pipeline = _indicator(\n                    "unknown",\n                    "Camera pipeline not required",\n                    "Management mode does not require an active camera pipeline.",\n                )\n            else:\n                camera_pipeline = _indicator(\n                    "fail",\n                    "Camera pipeline inactive",\n                    "Camera recording pipeline is not active.",\n                )\n\n            if last_frame_age_seconds is None:\n                stream_freshness = _indicator(\n                    "unknown",\n                    "Stream freshness unavailable",\n                    "No frame age is currently available to evaluate freshness.",\n                )\n            elif last_frame_age_seconds <= max_age_seconds:\n                stream_freshness = _indicator(\n                    "ok",\n                    "Stream is fresh",\n                    f"Last frame age {last_frame_age_seconds:.2f}s is within the {max_age_seconds:.2f}s threshold.",\n                )\n            else:\n                stream_freshness = _indicator(\n                    "fail",\n                    "Stream is stale",\n                    f"Last frame age {last_frame_age_seconds:.2f}s exceeds the {max_age_seconds:.2f}s threshold.",\n                )\n\n            connection_ratio = (\n                current_connections_count / max_connections_count\n                if max_connections_count > 0\n                else 0.0\n            )\n            if max_connections_count <= 0:\n                connection_capacity = _indicator(\n                    "unknown",\n                    "Connection capacity unavailable",\n                    "Maximum stream connections is not configured.",\n                )\n            elif connection_ratio >= 1.0:\n                connection_capacity = _indicator(\n                    "fail",\n                    "Connection capacity reached",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            elif connection_ratio >= 0.8:\n                connection_capacity = _indicator(\n                    "warn",\n                    "Connection capacity nearing limit",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n            else:\n                connection_capacity = _indicator(\n                    "ok",\n                    "Connection capacity healthy",\n                    f"{current_connections_count}/{max_connections_count} stream connections are in use.",\n                )\n\n            expected_real_camera = state.get("app_mode") == "webcam"\n            if config["mock_camera"] and expected_real_camera:\n                mock_mode = _indicator(\n                    "warn",\n                    "Mock camera enabled",\n                    "Mock camera is enabled while webcam mode is active.",\n                )\n            elif config["mock_camera"]:\n                mock_mode = _indicator(\n                    "ok",\n                    "Mock camera enabled",\n                    "Mock camera is enabled for a non-webcam mode.",\n                )\n            else:\n                mock_mode = _indicator(\n                    "ok",\n                    "Real camera mode",\n                    "Mock camera is disabled.",\n                )\n\n            return {\n                "camera_pipeline": camera_pipeline,\n                "stream_freshness": stream_freshness,\n                "connection_capacity": connection_capacity,\n                "mock_mode": mock_mode,\n            }\n\n        if state.get("app_mode") == "webcam":\n            tracker = state.get("connection_tracker")\n            recording_started = state.get("recording_started")\n            stream_stats = state.get("stream_stats")\n\n            current_connections = (\n                tracker.get_count() if isinstance(tracker, ConnectionTracker) else 0\n            )\n            camera_active = isinstance(recording_started, Event) and recording_started.is_set()\n            stream_status = (\n                get_stream_status(stream_stats, config["resolution"])\n                if isinstance(stream_stats, StreamStats)\n                else {"last_frame_age_seconds": None}\n            )\n            uptime_seconds = round(\n                max(\n                    0.0,\n                    time.monotonic() - getattr(app, "start_time_monotonic", 0.0),\n                ),\n                2,\n            )\n        else:\n            current_connections = 0\n            camera_active = False\n            stream_status = {"last_frame_age_seconds": None}\n            uptime_seconds = None\n\n        max_connections = state.get("max_stream_connections", config["max_stream_connections"])\n        health_check = _build_health_check(\n            camera_active,\n            stream_status,\n            current_connections,\n            max_connections,\n        )\n\n        return jsonify(\n            {\n                "camera_settings": {\n                    "resolution": list(config["resolution"]),\n                    "fps": config["fps"],\n                    "target_fps": config["target_fps"],\n                    "jpeg_quality": config["jpeg_quality"],\n                },\n                "stream_control": {\n                    "max_stream_connections": state.get(\n                        "max_stream_connections", config["max_stream_connections"]\n                    ),\n                    "current_stream_connections": current_connections,\n                    "max_frame_age_seconds": state.get(\n                        "max_frame_age_seconds", config["max_frame_age_seconds"]\n                    ),\n                    "cors_origins": config["cors_origins"],\n                },\n                "runtime": {\n                    "camera_active": camera_active,\n                    "mock_camera": config["mock_camera"],\n                    "uptime_seconds": uptime_seconds,\n                },\n                "health_check": health_check,\n                "timestamp": datetime.now(timezone.utc).isoformat(),\n                "app_mode": config["app_mode"],\n            }\n        ), 200\n\n    @app.route("/api/feature-flags")\n    def api_flags():\n        return jsonify(feature_flags.get_all_flags()), 200\n\n    @app.route("/api/setup/templates", methods=["GET"])\n    def api_setup_templates():\n        """Return setup templates, current config, detected devices, and constraints."""\n        try:\n            current_config = _collect_current_config()\n            detected_devices = _detect_camera_devices()\n            presets = _get_setup_presets()\n\n            return jsonify(\n                {\n                    "current_config": current_config,\n                    "available_presets": presets,\n                    "detected_devices": detected_devices,\n                    "constraints": {\n                        "resolution_examples": ["640x480", "1280x720", "1920x1080"],\n                        "fps_range": [0, 120],\n                        "jpeg_quality_range": [1, 100],\n                        "max_connections_range": [1, 100],\n                    },\n                    "app_mode": config["app_mode"],\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup templates endpoint failed")\n            return jsonify({"error": f"Failed to load setup templates: {e!s}"}), 500\n\n    @app.route("/api/setup/validate", methods=["POST"])\n    def api_setup_validate():\n        """Validate setup configuration values."""\n        try:\n            data = request.get_json() or {}\n            is_valid, errors = _validate_setup_config(data)\n\n            return jsonify(\n                {\n                    "valid": is_valid,\n                    "errors": errors,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup validation endpoint failed")\n            return jsonify({"valid": False, "errors": [f"Validation error: {e!s}"]}), 200\n\n    @app.route("/api/setup/generate", methods=["POST"])\n    def api_setup_generate():\n        """Generate docker-compose.yaml and .env files based on provided configuration."""\n        try:\n            data = request.get_json() or {}\n\n            # Validate first\n            is_valid, errors = _validate_setup_config(data)\n            if not is_valid:\n                error_msg = "; ".join(errors)\n                logger.warning(f"Setup generation validation failed: {error_msg}")\n                return jsonify({"error": f"Configuration invalid: {error_msg}"}), 400\n\n            # Detect devices\n            detected_devices = _detect_camera_devices()\n\n            # Generate files\n            docker_compose_content = _generate_docker_compose_content(data, detected_devices)\n            env_content = _generate_env_content(data)\n\n            return jsonify(\n                {\n                    "docker_compose_yaml": docker_compose_content,\n                    "env_content": env_content,\n                }\n            ), 200\n        except Exception as e:\n            logger.exception("Setup generation endpoint failed")\n            return jsonify({"error": f"Failed to generate configuration: {e!s}"}), 500\n\n    # NOTE: The following endpoints are defined in shared.py via register_shared_routes:\n\n\n\n\n    return app, limiter, state\n\n\ndef _register_request_logging(app: Flask) -> None:\n    health_endpoints = {"/health", "/ready"}\n\n    @app.before_request\n    def _track_request_start() -> None:\n        g.request_started_monotonic = time.monotonic()\n\n    @app.after_request\n    def _log_request(response):\n        request_started = getattr(g, "request_started_monotonic", None)\n        latency_ms = 0.0\n        if request_started is not None:\n            latency_ms = (time.monotonic() - request_started) * 1000\n\n        correlation_id = getattr(g, "correlation_id", None) or "none"\n        level = logging.DEBUG if request.path in health_endpoints else logging.INFO\n        logger.log(\n            level,\n            "request correlation_id=%s method=%s path=%s status=%s latency_ms=%.1f",\n            correlation_id,\n            request.method,\n            request.path,\n            response.status_code,\n            latency_ms,\n        )\n        return response\n\n\ndef create_management_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "management"\n    app, limiter, state = _create_base_app(cfg)\n    # Routes registered by these functions:\n    # @app.route("/")  # defined in _create_base_app\n    # @app.route("/health")  # registered in register_shared_routes (shared.py)\n    # @app.route("/ready")  # registered in register_shared_routes (shared.py)\n    register_shared_routes(app, state)\n    register_settings_routes(app)  # Add settings management API\n    register_management_camera_error_routes(app)\n    register_management_routes(\n        app,\n        cfg["node_registry_path"],\n        auth_token=cfg["management_auth_token"],\n        limiter=limiter,\n    )\n    # Log management mode startup configuration\n    logger.info(\n        "management_mode_initialized: auth_required=%s, registry_path=%s",\n        bool(cfg["management_auth_token"]),\n        cfg["node_registry_path"],\n    )\n    return app\n\n\ndef create_webcam_app(config: Optional[Dict[str, Any]] = None) -> Flask:\n    cfg = _load_config() if config is None else config\n    cfg = _merge_config_with_settings(cfg)  # Apply persisted settings\n    cfg["app_mode"] = "webcam"\n    app, _limiter, state = _create_base_app(cfg)\n\n    stream_stats = StreamStats()\n    output = FrameBuffer(stream_stats, target_fps=cfg["target_fps"])\n    state.update(\n        {\n            "output": output,\n            "stream_stats": stream_stats,\n            "connection_tracker": ConnectionTracker(),\n            "max_stream_connections": cfg["max_stream_connections"],\n            "api_test": {\n                "enabled": cfg["api_test_mode_enabled"],\n                "active": cfg["api_test_mode_enabled"],\n                "current_state_index": 0,\n                "scenario_list": [],\n                "last_transition_monotonic": time.monotonic(),\n                "cycle_interval_seconds": cfg["api_test_cycle_interval_seconds"],\n                "lock": RLock(),\n            },\n            "discovery_announcer": None,\n        }\n    )\n\n    default_api_test_scenarios = [\n        {\n            "status": "ok",\n            "stream_available": True,\n            "camera_active": True,\n            "fps": 24.0,\n            "connections": {"current": 1, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": True,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n        {\n            "status": "degraded",\n            "stream_available": False,\n            "camera_active": False,\n            "fps": 0.0,\n            "connections": {"current": 0, "max": 10},\n        },\n    ]\n\n    def _get_api_test_status_override(\n        uptime_seconds: float, max_connections: int\n    ) -> Optional[Dict[str, Any]]:\n        api_test_state = state.get("api_test")\n        if not api_test_state or not api_test_state.get("enabled"):\n            return None\n\n        lock = api_test_state.get("lock")\n        if not lock:\n            return None\n\n        with lock:\n            scenario_list = api_test_state.get("scenario_list") or default_api_test_scenarios\n            if not api_test_state.get("scenario_list"):\n                api_test_state["scenario_list"] = scenario_list\n\n            interval = api_test_state.get("cycle_interval_seconds", 5.0)\n            now = time.monotonic()\n\n            if (\n                api_test_state.get("active")\n                and interval > 0\n                and now - api_test_state.get("last_transition_monotonic", now) >= interval\n            ):\n                api_test_state["current_state_index"] = (\n                    api_test_state.get("current_state_index", 0) + 1\n                ) % len(scenario_list)\n                api_test_state["last_transition_monotonic"] = now\n\n            current_state_index = api_test_state.get("current_state_index", 0) % len(scenario_list)\n            scenario = scenario_list[current_state_index]\n            state_name = scenario.get("status", f"state-{current_state_index}")\n\n            next_transition_seconds = None\n            if api_test_state.get("active") and interval > 0:\n                elapsed = max(0.0, now - api_test_state.get("last_transition_monotonic", now))\n                next_transition_seconds = round(max(0.0, interval - elapsed), 3)\n\n        return {\n            "status": scenario["status"],\n            "app_mode": state["app_mode"],\n            "stream_available": scenario["stream_available"],\n            "camera_active": scenario["camera_active"],\n            "uptime_seconds": uptime_seconds,\n            "fps": scenario["fps"],\n            "connections": {\n                "current": scenario["connections"]["current"],\n                "max": max_connections,\n            },\n            "timestamp": datetime.now(timezone.utc).isoformat(),\n            "api_test": {\n                "enabled": api_test_state.get("enabled", False),\n                "active": api_test_state.get("active", False),\n                "state_index": current_state_index,\n                "state_name": state_name,\n                "next_transition_seconds": next_transition_seconds,\n            },\n        }\n\n    register_shared_routes(\n        app,\n        state,\n        get_stream_status=lambda: get_stream_status(stream_stats, cfg["resolution"]),\n        get_api_test_status_override=_get_api_test_status_override,\n    )\n    register_settings_routes(app)  # Add settings management API\n    register_webcam_control_plane_auth(\n        app,\n        cfg["management_auth_token"],\n        app_mode_provider=lambda: state["app_mode"],\n    )\n    # Routes registered by register_webcam_routes:\n    # @app.route("/stream.mjpg")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam")  # registered in register_webcam_routes (modes/webcam.py)\n    # @app.route("/webcam/")  # registered in register_webcam_routes (modes/webcam.py)\n    register_webcam_routes(app, state, is_flag_enabled=is_flag_enabled)\n    _run_webcam_mode(state, cfg)\n\n    if cfg["discovery_enabled"]:\n        if not cfg["discovery_token"]:\n            logger.warning("Discovery enabled but DISCOVERY_TOKEN is empty; announcer disabled")\n        else:\n            try:\n                discovery_cfg = {\n                    "discovery_node_id": cfg["discovery_node_id"],\n                    "discovery_base_url": cfg["base_url"],\n                }\n                payload = build_discovery_payload(discovery_cfg)\n                announcer = DiscoveryAnnouncer(\n                    management_url=cfg["discovery_management_url"],\n                    token=cfg["discovery_token"],\n                    interval_seconds=cfg["discovery_interval_seconds"],\n                    node_id=payload["node_id"],\n                    payload=payload,\n                    shutdown_event=state["shutdown_requested"],\n                )\n                announcer.start()\n                state["discovery_announcer"] = announcer\n                logger.info(\n                    "discovery_announcer_started: node_id=%s management_url=%s interval_seconds=%.1f",\n                    payload["node_id"],\n                    _redacted_url_for_logs(cfg["discovery_management_url"]),\n                    cfg["discovery_interval_seconds"],\n                )\n            except Exception:\n                logger.exception("Failed to initialize discovery announcer")\n    return app\n\n\ndef create_app_from_env() -> Flask:\n    cfg = _load_config()\n    try:\n        validate_all_config(cfg)\n    except ConfigValidationError as e:\n        error_msg = str(e)\n        if e.hint:\n            error_msg += f" ({e.hint})"\n        logger.error("Configuration validation failed: %s", error_msg)\n        raise ValueError(error_msg) from e\n\n    app = create_management_app(cfg) if cfg["app_mode"] == "management" else create_webcam_app(cfg)\n    logger.info("Application started in %s mode", cfg["app_mode"])\n    return app\n\n\ndef _check_device_availability(cfg: Dict[str, Any]) -> None:\n    """Validate that required camera device nodes exist before initialization."""\n    if cfg["mock_camera"]:\n        return\n\n    required_devices = ["/dev/vchiq"]\n    device_patterns = {\n        "video": range(10),  # /dev/video0 through /dev/video9\n        "media": range(10),  # /dev/media0 through /dev/media9\n        "v4l_subdev": range(64),  # /dev/v4l-subdev0 through /dev/v4l-subdev63\n        "dma_heap": ["system", "linux,cma"],  # Common dma_heap device names\n    }\n\n    device_pattern_display = {\n        "video": "/dev/video*",\n        "media": "/dev/media*",\n        "v4l_subdev": "/dev/v4l-subdev*",\n        "dma_heap": "/dev/dma_heap/*",\n    }\n\n    discovered_nodes = {\n        "video": [\n            Path(f"/dev/video{i}")\n            for i in device_patterns["video"]\n            if Path(f"/dev/video{i}").exists()\n        ],\n        "media": [\n            Path(f"/dev/media{i}")\n            for i in device_patterns["media"]\n            if Path(f"/dev/media{i}").exists()\n        ],\n        "v4l_subdev": [\n            Path(f"/dev/v4l-subdev{i}")\n            for i in device_patterns["v4l_subdev"]\n            if Path(f"/dev/v4l-subdev{i}").exists()\n        ],\n        "dma_heap": [\n            Path(f"/dev/dma_heap/{name}")\n            for name in device_patterns["dma_heap"]\n            if Path(f"/dev/dma_heap/{name}").exists()\n        ],\n    }\n\n    preflight_summary = {\n        "counts": {name: len(paths) for name, paths in discovered_nodes.items()},\n        "samples": {name: paths[:3] for name, paths in discovered_nodes.items()},\n    }\n    logger.info("Camera preflight device summary: %s", preflight_summary)\n\n    missing_critical = [device for device in required_devices if not Path(device).exists()]\n\n    if missing_critical:\n        logger.warning(\n            "Critical camera devices not found: %s. "\n            "Check device mappings in docker-compose.yaml and run ./detect-devices.sh on host.",\n            ", ".join(missing_critical),\n        )\n\n    if not (\n        discovered_nodes["video"] or discovered_nodes["media"] or discovered_nodes["v4l_subdev"]\n    ):\n        logger.warning(\n            "No /dev/video*, /dev/media*, or /dev/v4l-subdev* nodes were detected during preflight. "\n            "Camera enumeration is likely to fail in this container. "\n            "Verify host camera drivers and container device mappings."\n        )\n    elif not discovered_nodes["video"]:\n        missing_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if not discovered_nodes[group_name]\n        ]\n        present_node_groups = [\n            device_pattern_display[group_name]\n            for group_name in ("video", "media", "v4l_subdev")\n            if discovered_nodes[group_name]\n        ]\n        logger.warning(\n            "Camera device preflight found partial node availability. Present groups: %s. "\n            "Missing groups: %s. Streaming is likely unavailable; verify device mappings and driver state.",\n            ", ".join(present_node_groups),\n            ", ".join(missing_node_groups),\n        )\n\n\ndef _shutdown_camera(state: Dict[str, Any]) -> None:\n    shutdown_requested: Optional[Event] = state.get("shutdown_requested")\n    if shutdown_requested is not None:\n        shutdown_requested.set()\n\n    recording_started: Optional[Event] = state.get("recording_started")\n    if recording_started is not None:\n        recording_started.clear()\n\n    camera_lock: Optional[RLock] = state.get("camera_lock")\n    if camera_lock is None:\n        logger.warning("Camera lock not found in shutdown state")\n        return\n\n    with camera_lock:\n        picam2_instance = state.get("picam2_instance")\n        if picam2_instance is None:\n            return\n\n        try:\n            if getattr(picam2_instance, "started", False):\n                picam2_instance.stop_recording()  # stop_recording marker\n        except Exception:\n            logger.exception("Failed to stop camera recording during shutdown")\n        finally:\n            state["picam2_instance"] = None\n\n\ndef _get_camera_info(picamera2_cls: Any) -> Tuple[list, str]:\n    try:\n        return _picamera2_global_camera_info(), "picamera2.global_camera_info"\n    except (ImportError, AttributeError, NameError):\n        logger.debug(\n            "picamera2.global_camera_info import unavailable; falling back to Picamera2 class method"\n        )\n\n    class_global_camera_info = getattr(picamera2_cls, "global_camera_info", None)\n    if callable(class_global_camera_info):\n        try:\n            return class_global_camera_info(), "Picamera2.global_camera_info"\n        except Exception:\n            logger.debug("Picamera2.global_camera_info call failed at runtime")\n\n    logger.warning(\n        "Unable to query camera inventory from picamera2. Proceeding with empty camera list. "\n        "If camera detection fails, verify the installed picamera2 version supports global_camera_info."\n    )\n    return [], "none"\n\n\ndef _init_mock_camera_frames(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize mock camera frame generation."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n\n    if cfg["cat_gif_enabled"]:\n        # Use cat GIF streaming mode\n        cat_generator = CatGifGenerator(\n            api_url=cfg["cataas_api_url"],\n            resolution=cfg["resolution"],\n            jpeg_quality=cfg["jpeg_quality"],\n            target_fps=cfg["fps"] if cfg["fps"] > 0 else 10,\n            cache_ttl_seconds=cfg["cat_gif_cache_ttl_seconds"],\n        )\n        state["cat_gif_generator"] = cat_generator\n\n        def generate_cat_gif_frames() -> None:\n            recording_started.set()\n            try:\n                for frame in cat_generator.generate_frames():\n                    if shutdown_requested.is_set():\n                        break\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_cat_gif_frames, daemon=True).start()\n    else:\n        # Use classic black frame mock mode\n        fallback = Image.new("RGB", cfg["resolution"], color=(0, 0, 0))\n        buf = io.BytesIO()\n        fallback.save(buf, format="JPEG", quality=cfg["jpeg_quality"])\n        frame = buf.getvalue()\n\n        def generate_mock_frames() -> None:\n            recording_started.set()\n            try:\n                while not shutdown_requested.is_set():\n                    time.sleep(1 / (cfg["fps"] if cfg["fps"] > 0 else 10))\n                    output.write(frame)\n            finally:\n                recording_started.clear()\n\n        Thread(target=generate_mock_frames, daemon=True).start()\n\n\ndef _init_real_camera(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    """Initialize real camera recording."""\n    recording_started: Event = state["recording_started"]\n    output: FrameBuffer = state["output"]\n    shutdown_requested: Event = state["shutdown_requested"]\n    camera_lock: RLock = state["camera_lock"]\n\n    picamera2_cls, jpeg_encoder_cls, file_output_cls = import_camera_components(\n        cfg["allow_pykms_mock"]\n    )\n    try:\n        # Detect available cameras before initialization\n        try:\n            detected_devices = _detect_camera_devices()\n            camera_inventory = {\n                "video_devices": detected_devices.get("video_devices", []),\n                "media_devices": detected_devices.get("media_devices", []),\n                "v4l_subdev_devices": detected_devices.get("v4l_subdev_devices", []),\n                "dma_heap_devices": detected_devices.get("dma_heap_devices", []),\n                "vchiq_exists": detected_devices.get("vchiq_device", False),\n            }\n            camera_info, detection_path = _get_camera_info(\n                picamera2_cls\n            )  # global_camera_info() marker\n            logger.info("Camera inventory detection path: %s", detection_path)\n            if not camera_info:\n                logger.error(\n                    "No cameras detected by picamera2 enumeration",\n                    extra={\n                        "camera_info_detection_path": detection_path,\n                        "camera_device_inventory": camera_inventory,\n                    },\n                )\n                message = "No cameras detected. Check device mappings and camera hardware."\n                raise RuntimeError(message)\n            logger.info(f"Detected {len(camera_info)} camera(s) available")\n        except IndexError as e:  # except IndexError marker for camera detection\n            message = (\n                "Camera enumeration failed. Verify device mappings and permissions. "\n                "See ./detect-devices.sh and docker-compose.yaml for configuration."\n            )\n            raise RuntimeError(message) from e\n\n        with camera_lock:\n            if shutdown_requested.is_set():\n                message = "Shutdown requested before camera startup completed"\n                raise RuntimeError(message)\n\n            picam2_instance = picamera2_cls()  # Picamera2() marker\n            state["picam2_instance"] = picam2_instance\n            video_config = picam2_instance.create_video_configuration(\n                main={"size": cfg["resolution"], "format": "BGR888"}\n            )  # create_video_configuration marker\n            picam2_instance.configure(video_config)\n            picam2_instance.start_recording(\n                jpeg_encoder_cls(q=cfg["jpeg_quality"]), file_output_cls(output)\n            )  # start_recording marker\n        recording_started.set()\n    except PermissionError as e:  # except PermissionError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Permission denied accessing camera device. Check device mappings in "\n            "docker-compose.yaml and run ./detect-devices.sh on the host for guidance.",\n            exc_info=e,\n        )\n        raise\n    except RuntimeError as e:  # except RuntimeError marker\n        _shutdown_camera(state)\n        logger.error(\n            "Camera initialization failed. This may indicate missing device mappings, "\n            "insufficient permissions, or unavailable hardware. "\n            "See ./detect-devices.sh and docker-compose.yaml for troubleshooting.",\n            exc_info=e,\n        )\n        raise\n    except Exception as e:  # except Exception marker\n        _shutdown_camera(state)\n        logger.error(\n            "Unexpected error during camera initialization. "\n            "Check device availability and permissions.",\n            exc_info=e,\n        )\n        raise\n\n\ndef _run_webcam_mode(state: Dict[str, Any], cfg: Dict[str, Any]) -> None:\n    # Picamera2() / create_video_configuration / start_recording markers are intentionally preserved.\n\n    # Validate device availability early\n    _check_device_availability(cfg)\n\n    if cfg["mock_camera"]:\n        _init_mock_camera_frames(state, cfg)\n    else:\n        _init_real_camera(state, cfg)\n\n\ndef handle_shutdown(app: Flask, signum: int, _frame: Optional[object]) -> None:\n    app_state = getattr(app, "motion_state", None)\n    if isinstance(app_state, dict):\n        announcer = app_state.get("discovery_announcer")\n        if announcer is not None:\n            announcer.stop()\n        _shutdown_camera(app_state)\n    raise SystemExit(signum)\n\n\nif __name__ == "__main__":\n    app = create_app_from_env()\n    signal.signal(signal.SIGTERM, lambda signum, frame: handle_shutdown(app, signum, frame))\n    signal.signal(signal.SIGINT, lambda signum, frame: handle_shutdown(app, signum, frame))\n    # app.run marker preserved for compatibility checks with static tests.\n    server = make_server(\n        app.motion_config["bind_host"], app.motion_config["bind_port"], app, threaded=True\n    )\n    server.serve_forever()\n'
============ 2 failed, 271 passed, 22 skipped, 9 warnings in 18.70s ============
